{
  "language": "Solidity",
  "sources": {
    "contracts/BorrowWrapperToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"./WrapperToken.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title BorrowWrapperToken\n/// @author @samparsky\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract BorrowWrapperToken is WrapperToken {}\n"
    },
    "contracts/WrapperToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"./token/ERC20Permit.sol\";\nimport \"./interfaces/IRewardDistributorManager.sol\";\nimport \"./interfaces/IBSLendingPair.sol\";\nimport \"./interfaces/IBSWrapperToken.sol\";\nimport \"./token/IERC20Details.sol\";\nimport \"./util/Initializable.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title WrapperToken\n/// @author @samparsky\n/// @dev\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\n\nabstract contract WrapperTokenBase is ERC20Permit, Initializable {\n\n    /// @dev reward distributor Manager\n    IRewardDistributorManager public rewardManager;\n\n    /// @dev underlying wrapper token\n    address public underlying;\n\n    /// @dev the LendingPair is the \"owner\" for WrapperTokens\n    address internal _owner;\n\n\n     /**\n     * @dev Throws if called by any account other than the lendingpair.\n     */\n    modifier onlyLendingPair() {\n        require(address(_owner) == msg.sender, \"ONLY_LENDING_PAIR\");\n        _;\n    }\n\n    function _rewardHook(address _from, address _to) internal {\n        rewardManager.accumulateRewards(_from, _to);\n    }\n}\n\ncontract WrapperToken is  IBSWrapperToken, WrapperTokenBase {\n    /// @dev wrapper token version\n    uint256 constant public VERSION = 0x1;\n\n    /// @notice\n    function initialize(\n        address __owner,\n        address _underlying,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        IRewardDistributorManager _manager\n    ) external virtual override initializer {\n        require(__owner != address(0), \"invalid owner\");\n        require(_underlying != address(0), \"invalid underlying\");\n\n        _owner = __owner;\n        uint8 underlyingDecimal = IERC20Details(_underlying).decimals();\n        initializeERC20(_tokenName, _tokenSymbol, underlyingDecimal);\n        initializeERC20Permit(_tokenName);\n        underlying = _underlying;\n        rewardManager = _manager;\n    }\n\n    /**\n    @notice mint is an only owner function that allows the owner to mint new tokens to an input account\n    @param _to is the address that will receive the new tokens\n    @param _amount is the amount of token they will receive\n    **/\n    function mint(address _to, uint256 _amount) external virtual override onlyLendingPair {\n        _rewardHook(address(0), _to);\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @notice burn is an only owner function that allows the owner to burn  tokens from an input account\n     * @dev IMPORTANT: it reverts if user doesn't have enough balance\n     * @param _from is the address where the tokens will be burnt\n     * @param _amount is the amount of token to be burnt\n     **/\n    function burn(address _from, uint256 _amount) external virtual override onlyLendingPair {\n        _rewardHook(_from, address(0));\n        _burn(_from, _amount);\n    }\n\n    function owner() external view override returns (address) {\n        return _owner;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        _rewardHook(sender, recipient);\n        super._transfer(sender, recipient, amount);\n    }\n}\n"
    },
    "contracts/token/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./ERC20.sol\";\nimport \"./EIP712.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n */\n\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    mapping(address => uint256) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function initializeERC20Permit(string memory _name) internal {\n        initializeEIP712(_name, \"1\");\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash =\n            keccak256(\n                abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner], deadline)\n            );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _nonces[owner]++;\n        _approve(owner, spender, amount);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "contracts/interfaces/IRewardDistributorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"./IRewardDistributor.sol\";\n\ninterface IRewardDistributorManager {\n    /// @dev Emitted on Initialization\n    event Initialized(address owner, uint256 timestamp);\n\n    event ApprovedDistributor(IRewardDistributor distributor, uint256 timestamp);\n    event AddReward(address tokenAddr, IRewardDistributor distributor, uint256 timestamp);\n    event RemoveReward(address tokenAddr, IRewardDistributor distributor, uint256 timestamp);\n    event TransferControl(address _newTeam, uint256 timestamp);\n    event OwnershipAccepted(address newOwner, uint256 timestamp);\n\n    function activateReward(address _tokenAddr) external;\n\n    function removeReward(address _tokenAddr, IRewardDistributor _distributor) external;\n\n    function accumulateRewards(address _from, address _to) external;\n}\n"
    },
    "contracts/interfaces/IBSLendingPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IPriceOracleAggregator.sol\";\nimport \"./IBSWrapperToken.sol\";\nimport \"./IDebtToken.sol\";\nimport \"./IBSVault.sol\";\nimport \"../DataTypes.sol\";\n\ninterface IBSLendingPair {\n    event Initialized(\n        address indexed pair,\n        address indexed asset,\n        address indexed collateralAsset,\n        address pauseGuardian\n    );\n\n    /**\n     * Emitted on deposit\n     *\n     * @param pair The pair being interacted with\n     * @param asset The asset deposited in the pair\n     * @param tokenReceipeint The user the receives the bsTokens\n     * @param user The user that made the deposit\n     * @param amount The amount deposited\n     **/\n    event Deposit(\n        address indexed pair,\n        address indexed asset,\n        address indexed tokenReceipeint,\n        address user,\n        uint256 amount\n    );\n\n    event Borrow(address indexed borrower, uint256 amount);\n\n    /**\n     * Emitted on Redeem\n     *\n     * @param pair The pair being interacted with\n     * @param asset The asset withdraw in the pair\n     * @param user The user that's making the withdrawal\n     * @param to The user the receives the withdrawn tokens\n     * @param amount The amount being withdrawn\n     **/\n    event Redeem(\n        address indexed pair,\n        address indexed asset,\n        address indexed user,\n        address to,\n        uint256 amount,\n        uint256 amountofWrappedBurned\n    );\n\n    event WithdrawCollateral(address account, uint256 amount);\n\n    event ReserveWithdraw(address user, uint256 shares);\n\n    /**\n     * Emitted on repay\n     *\n     * @param pair The pair being interacted with\n     * @param asset The asset repaid in the pair\n     * @param beneficiary The user that's getting their debt reduced\n     * @param repayer The user that's providing the funds\n     * @param amount The amount being repaid\n     **/\n    event Repay(\n        address indexed pair,\n        address indexed asset,\n        address indexed beneficiary,\n        address repayer,\n        uint256 amount\n    );\n\n    /**\n     * Emitted on liquidation\n     *\n     * @param pair The pair being interacted with\n     * @param asset The asset that getting liquidated\n     * @param user The user that's getting liquidated\n     * @param liquidatedCollateralAmount The of collateral transferred to the liquidator\n     * @param liquidator The liquidator\n     **/\n    event Liquidate(\n        address indexed pair,\n        address indexed asset,\n        address indexed user,\n        uint256 liquidatedCollateralAmount,\n        address liquidator\n    );\n\n    /**\n     * @dev Emitted on flashLoan\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium\n    );\n\n    /**\n     * @dev Emitted on interest accrued\n     * @param accrualBlockNumber block number\n     * @param borrowIndex borrow index\n     * @param totalBorrows total borrows\n     * @param totalReserves total reserves\n     **/\n    event InterestAccrued(\n        address indexed pair,\n        uint256 accrualBlockNumber,\n        uint256 borrowIndex,\n        uint256 totalBorrows,\n        uint256 totalReserves\n    );\n\n    event InterestShortCircuit(uint256 blockNumber);\n\n    event ActionPaused(uint8 action, uint256 timestamp);\n    event ActionUnPaused(uint8 action, uint256 timestamp);\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        IERC20 _asset,\n        IERC20 _collateralAsset,\n        DataTypes.BorrowAssetConfig calldata borrowConfig,\n        IBSWrapperToken _wrappedCollateralAsset,\n        IInterestRateModel _interestRate,\n        address _pauseGuardian\n    ) external;\n\n    function asset() external view returns (IERC20);\n\n    function depositBorrowAsset(address _tokenReceipeint, uint256 _amount) external;\n\n    function depositCollateral(address _tokenReceipeint, uint256 _vaultShareAmount) external;\n\n    function redeem(address _to, uint256 _amount) external;\n\n    function collateralOfAccount(address _account) external view returns (uint256);\n\n    function getMaxWithdrawAllowed(address account) external returns (uint256);\n\n    function oracle() external view returns (IPriceOracleAggregator);\n\n    function collateralAsset() external view returns (IERC20);\n\n    function calcBorrowLimit(uint256 amount) external view returns (uint256);\n\n    function accountInterestIndex(address) external view returns (uint256);\n\n    function borrowIndex() external view returns (uint256);\n\n    function debtToken() external view returns (IDebtToken);\n\n    function borrowBalancePrior(address _account) external view returns (uint256);\n\n    function wrapperBorrowedAsset() external view returns (IBSWrapperToken);\n\n    function wrappedCollateralAsset() external view returns (IBSWrapperToken);\n\n    function totalReserves() external view returns (uint256);\n\n    function withdrawFees(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IBSWrapperToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IRewardDistributorManager.sol\";\n\ninterface IBSWrapperTokenBase is IERC20 {\n    function initialize(\n        address _owner,\n        address _underlying,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        IRewardDistributorManager _manager\n    ) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function owner() external view returns (address);\n}\n\ninterface IBSWrapperToken is IBSWrapperTokenBase {\n    function mint(address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/token/IERC20Details.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\ninterface IERC20Details {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/util/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            _initializing || _isConstructor() || !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\n * !!! samparsky modified: use initializeERC20 to replace constructor for proxy\n */\ncontract ERC20 is IERC20 {\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    function initializeERC20(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += _amount;\n        _balances[_account] += _amount;\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(account, address(0), amount);\n    }\n}\n"
    },
    "contracts/token/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n */\n\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    // samparsky: remove immutable to be initiated, it should only be set once in initialize\n    bytes32 private _CACHED_DOMAIN_SEPARATOR;\n    uint256 private _CACHED_CHAIN_ID;\n\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function initializeEIP712(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash =\n            keccak256(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n            );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IRewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewardDistributor {\n    event Initialized(\n        IERC20 indexed _rewardToken,\n        uint256 _amountDistributePerSecond,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        address _guardian,\n        uint256 timestamp\n    );\n\n    function accumulateReward(address _tokenAddr, address _user) external;\n\n    function endTimestamp() external returns (uint256);\n\n    function initialize(\n        string calldata _name,\n        IERC20 _rewardToken,\n        uint256 _amountDistributePerSecond,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        address _guardian\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IOracle.sol\";\n\ninterface IPriceOracleAggregator {\n    event UpdateOracle(IERC20 token, IOracle oracle);\n\n    function getPriceInUSD(IERC20 _token) external view returns (uint256);\n\n    function getPriceInUSDMultiple(IERC20[] calldata _tokens)\n        external\n        view\n        returns (uint256[] memory);\n\n    function setOracleForAsset(IERC20[] calldata _asset, IOracle[] calldata _oracle) external;\n\n    event OwnershipAccepted(address newOwner, uint256 timestamp);\n    event TransferControl(address _newTeam, uint256 timestamp);\n    event StableTokenAdded(IERC20 _token, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/IDebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport {IBSWrapperTokenBase} from \"./IBSWrapperToken.sol\";\n\ninterface IDebtToken is IBSWrapperTokenBase {\n    event DelegateBorrow(address from, address to, uint256 amount, uint256 timestamp);\n\n    function increaseTotalDebt(uint256 _amount) external;\n\n    function principal(address _account) external view returns (uint256);\n\n    function mint(\n        address _to,\n        address _owner,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IBSVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IERC3156FlashLender.sol\";\n\ninterface IBSVault is IERC3156FlashLender {\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n\n    /// @notice Emitted on deposit\n    /// @param token being deposited\n    /// @param from address making the depsoit\n    /// @param to address to credit the tokens being deposited\n    /// @param amount being deposited\n    /// @param shares the represent the amount deposited in the vault\n    event Deposit(\n        IERC20 indexed token,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 shares\n    );\n\n    /// @notice Emitted on withdraw\n    /// @param token being deposited\n    /// @param from address making the depsoit\n    /// @param to address to credit the tokens being withdrawn\n    /// @param amount Amount of underlying being withdrawn\n    /// @param shares the represent the amount withdraw from the vault\n    event Withdraw(\n        IERC20 indexed token,\n        address indexed from,\n        address indexed to,\n        uint256 shares,\n        uint256 amount\n    );\n\n    event Transfer(IERC20 indexed token, address indexed from, address indexed to, uint256 amount);\n\n    event FlashLoan(\n        address indexed borrower,\n        IERC20 indexed token,\n        uint256 amount,\n        uint256 feeAmount,\n        address indexed receiver\n    );\n\n    event TransferControl(address _newTeam, uint256 timestamp);\n\n    event UpdateFlashLoanRate(uint256 newRate);\n\n    event Approval(address indexed user, address indexed allowed, bool status);\n\n    event OwnershipAccepted(address newOwner, uint256 timestamp);\n\n    event RegisterProtocol(address sender);\n\n    event AllowContract(address whitelist, bool status);\n\n    event RescueFunds(IERC20 token, uint256 amount);\n\n    // ************** //\n    // *** FUNCTIONS *** //\n    // ************** //\n\n    function initialize(uint256 _flashLoanRate, address _owner) external;\n\n    function approveContract(\n        address _user,\n        address _contract,\n        bool _status,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function deposit(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (uint256);\n\n    function withdraw(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (uint256);\n\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function transfer(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _shares\n    ) external;\n\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool ceil\n    ) external view returns (uint256);\n\n    function toUnderlying(IERC20 token, uint256 share) external view returns (uint256);\n\n}\n"
    },
    "contracts/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IBSWrapperToken.sol\";\nimport \"./interfaces/IDebtToken.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title DataTypes\n/// @author @samparsky\n////////////////////////////////////////////////////////////////////////////////////////////\n\nlibrary DataTypes {\n    struct BorrowAssetConfig {\n        uint256 initialExchangeRateMantissa;\n        uint256 reserveFactorMantissa;\n        uint256 collateralFactor;\n        IBSWrapperToken wrappedBorrowAsset;\n        uint256 liquidationFee;\n        IDebtToken debtToken;\n    }\n\n    function validBorrowAssetConfig(BorrowAssetConfig memory self, address _owner) internal view {\n        require(self.initialExchangeRateMantissa > 0, \"E\");\n        require(self.reserveFactorMantissa > 0, \"F\");\n        require(self.collateralFactor > 0, \"C\");\n        require(self.liquidationFee > 0, \"L\");\n        require(address(self.wrappedBorrowAsset) != address(0), \"B\");\n        require(address(self.debtToken) != address(0), \"IB\");\n        require(self.wrappedBorrowAsset.owner() == _owner, \"IW\");\n        require(self.debtToken.owner() == _owner, \"IVW\");\n    }\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\ninterface IOracle {\n    /// @notice Price update event\n    /// @param asset the asset\n    /// @param newPrice price of the asset\n    event PriceUpdated(address asset, uint256 newPrice);\n\n    /// @dev returns latest answer\n    function latestAnswer() external view returns (int256);\n}\n"
    },
    "contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.1;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\ninterface IInterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/DebtToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport {WrapperTokenBase} from \"./WrapperToken.sol\";\nimport \"./interfaces/IBSLendingPair.sol\";\nimport \"./interfaces/IDebtToken.sol\";\nimport \"./token/ERC20Permit.sol\";\nimport \"./token/IERC20Details.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title DebtToken\n/// @author @samparsky\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract DebtToken is IDebtToken, WrapperTokenBase {\n    /// @dev debt token version\n    uint256 constant public VERSION = 0x1;\n\n    /// @dev for introspection\n    bool constant isDebtToken = true;\n\n    /// @dev debt token delegate borrow message digest\n    bytes32 internal constant _DEBT_BORROW_DELEGATE_SIGNATURE_TYPE_HASH =\n        keccak256(\n            \"BorrowDelegate(bytes32 warning,address from,address to,uint amount,uint256 nonce)\"\n        );\n\n    /// @dev user delegated borrow allowances\n    mapping(address => mapping(address => uint256)) private _borrowAllowances;\n\n    /// @notice mapping of user to approval nonce\n    mapping(address => uint256) public userBorrowAllowanceNonce;\n\n    /// @notice initialize\n    function initialize(\n        address __owner,\n        address _underlying,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        IRewardDistributorManager _manager\n    ) external virtual override initializer {\n        require(__owner != address(0), \"invalid owner\");\n        require(_underlying != address(0), \"invalid underlying\");\n\n        _owner = __owner;\n        uint8 underlyingDecimal = IERC20Details(_underlying).decimals();\n        initializeERC20(_tokenName, _tokenSymbol, underlyingDecimal);\n        initializeERC20Permit(_tokenName);\n        underlying = _underlying;\n        rewardManager = _manager;\n    }\n\n    function principal(address _account) external view override returns (uint256) {\n        return _balances[_account];\n    }\n\n    /// @dev calculates the debt balance of account\n    function balanceOf(address _account) public view override(IERC20, ERC20) returns (uint256) {\n        return IBSLendingPair(_owner).borrowBalancePrior(_account);\n    }\n\n    /// @dev mint debt tokens to the debtOwner address\n    /// @param _debtOwner the address to mint the debt tokens to\n    /// @param _to the address requesting the debt, when (_to != _debtOwner) debtOwner must have \n    /// delegated some borrow allowance to the _to address\n    /// @param _amount the amount of debt tokens to mint\n    function mint(address _debtOwner, address _to, uint256 _amount) external override onlyLendingPair {\n        require(_debtOwner != address(0), \"INVALID_DEBT_OWNER\");\n        if(_debtOwner != _to) {\n            _decreaseBorrowAllowance(_debtOwner, _to, _amount);\n        }\n        _rewardHook(address(0), _debtOwner);\n        _mint(_debtOwner, _amount);\n    }\n\n    function _mint(address _account, uint256 _amount) internal virtual override {\n        require(_account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += _amount;\n        _balances[_account] = balanceOf(_account) + _amount;\n        emit Transfer(address(0), _account, _amount);\n    }\n\n\n    function owner() external view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice burn is an only owner function that allows the owner to burn  tokens from an input account\n     * @param _from is the address where the tokens will be burnt\n     * @param _amount is the amount of token to be burnt\n     **/\n    function burn(address _from, uint256 _amount)\n        external\n        override(IBSWrapperTokenBase)\n        onlyLendingPair\n    {\n        _rewardHook(_from, address(0));\n        _balances[_from] = balanceOf(_from) - _amount;\n        if (_amount > _totalSupply) {\n            _totalSupply = 0;\n        } else {\n            _totalSupply -= _amount;\n        }\n    }\n\n    function borrowAllowance(address _from, address _to) external view returns(uint256) {\n        return _borrowAllowances[_from][_to];\n    }\n\n    function delegateBorrow(address _to, uint256 _amount) external {\n        _delegateBorrowInternal(msg.sender, _to, _amount);\n    }\n\n    function _delegateBorrowInternal(address _from, address _to, uint256 _amount) internal {\n        require(_to != address(0), \"INVALID_TO\");\n\n        _borrowAllowances[_from][_to] = _amount;\n        emit DelegateBorrow(_from, _to, _amount, block.timestamp);\n    }\n\n    function delegateBorrowWithSignedMessage(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(_to != address(0), \"INVALID_TO\");\n\n         bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    _domainSeparatorV4(),\n                    keccak256(\n                        abi.encode(\n                            _DEBT_BORROW_DELEGATE_SIGNATURE_TYPE_HASH,\n                            keccak256(\n                                \"You are delegating borrow to user, read more here: https://warp.finance/delegate\"\n                            ),\n                            _from,\n                            _to,\n                            _amount,\n                            userBorrowAllowanceNonce[_from]++\n                        )\n                    )\n                )\n            );\n        \n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress == _from, \"INVALID_SIGNATURE\");\n\n        _delegateBorrowInternal(_from, _to, _amount);\n    }\n\n    function _decreaseBorrowAllowance(address _from, address _to, uint256 _amount) internal {\n        _borrowAllowances[_from][_to] =  _borrowAllowances[_from][_to] - _amount;\n    }\n    \n    /// @notice used to increase the debt of the system\n    /// @param _amount is the amount to increase\n    function increaseTotalDebt(uint256 _amount) external override onlyLendingPair {\n        _totalSupply = _totalSupply + _amount;\n    }\n\n    function transfer(\n        address, /*recipient*/\n        uint256 /*amount*/\n    ) public pure override(ERC20, IERC20) returns (bool) {\n        revert(\"TRANSFER_NOT_SUPPORTED\");\n    }\n\n    function approve(\n        address, /*spender*/\n        uint256 /*amount*/\n    ) public virtual override(ERC20, IERC20) returns (bool) {\n        revert(\"APPROVAL_NOT_SUPPORTED\");\n    }\n\n    function allowance(\n        address, /*owner*/\n        address /*spender*/\n    ) public view virtual override(ERC20, IERC20) returns (uint256) {\n        revert(\"ALLOWANCE_NOT_SUPPORTED\");\n    }\n\n    function transferFrom(\n        address, /*sender*/\n        address, /*recipient*/\n        uint256 /*amount*/\n    ) public virtual override(ERC20, IERC20) returns (bool) {\n        revert(\"TRANSFER_NOT_SUPPORTED\");\n    }\n\n    function increaseAllowance(\n        address, /*spender*/\n        uint256 /*addedValue*/\n    ) public virtual override returns (bool) {\n        revert(\"ALLOWANCE_NOT_SUPPORTED\");\n    }\n\n    function decreaseAllowance(\n        address, /*spender*/\n        uint256 /*subtractedValue*/\n    ) public virtual override returns (bool) {\n        revert(\"ALLOWANCE_NOT_SUPPORTED\");\n    }\n\n    function permit(\n        address /* owner */,\n        address /* spender */,\n        uint256 /* amount */,\n        uint256 /* deadline */,\n        uint8 /* v */,\n        bytes32 /* r */,\n        bytes32 /* s */\n    ) public virtual override {\n        revert(\"PERMIT_NOT_SUPPORTED\");\n    }\n}\n"
    },
    "contracts/LendingPairFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IPriceOracleAggregator.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IBSLendingPair.sol\";\nimport \"./interfaces/IBSWrapperToken.sol\";\nimport \"./interfaces/IDebtToken.sol\";\nimport \"./interfaces/IRewardDistributorManager.sol\";\nimport \"./interest/JumpRateModelV2.sol\";\nimport \"./token/IERC20Details.sol\";\nimport \"./DataTypes.sol\";\n\ncontract LendingPairFactory is Pausable {\n    using Clones for address;\n\n    address public immutable owner;\n\n    address public lendingPairImplementation;\n    address public collateralWrapperImplementation;\n    address public debtTokenImplementation;\n    address public borrowAssetWrapperImplementation;\n    address public rewardDistributionManager;\n\n    address[] public allPairs;\n\n    mapping (address => bool) public validInterestRateModels;\n\n    event NewLendingPair(address pair, uint256 created);\n    event LogicContractUpdated(address pairLogic);\n    event NewInterestRateModel(address ir, uint256 timestamp);\n\n    /// @notice modifier to allow only the owner to call a function\n    modifier onlyOwner {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    constructor(\n        address _owner,\n        address _pairLogic,\n        address _collateralWrapperLogic,\n        address _debtTokenLogic,\n        address _borrowAssetWrapperLogic,\n        address _rewardDistributionManager\n    ) {\n        require(_owner != address(0), \"inv_o\");\n        require(_pairLogic != address(0), \"inv_l\");\n        require(_collateralWrapperLogic != address(0), \"inv_c\");\n        require(_debtTokenLogic != address(0), \"inv_d\");\n        require(_borrowAssetWrapperLogic != address(0), \"inv_b\");\n        require(_rewardDistributionManager != address(0), \"inv_r\");\n\n        owner = _owner;\n        lendingPairImplementation = _pairLogic;\n        collateralWrapperImplementation = _collateralWrapperLogic;\n        debtTokenImplementation = _debtTokenLogic;\n        borrowAssetWrapperImplementation = _borrowAssetWrapperLogic;\n        rewardDistributionManager = _rewardDistributionManager;\n    }\n\n    /// @notice pause\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpause\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function updatePairImpl(address _newLogicContract) external onlyOwner {\n        require(_newLogicContract != address(0), \"INV_C\");\n        lendingPairImplementation = _newLogicContract;\n        emit LogicContractUpdated(_newLogicContract);\n    }\n\n    function updateCollateralWrapperImpl(address _newLogicContract) external onlyOwner {\n        require(_newLogicContract != address(0), \"INV_C\");\n        collateralWrapperImplementation = _newLogicContract;\n        emit LogicContractUpdated(_newLogicContract);\n    }\n\n    function updateDebtTokenImpl(address _newLogicContract) external onlyOwner {\n        require(_newLogicContract != address(0), \"INV_C\");\n        debtTokenImplementation = _newLogicContract;\n        emit LogicContractUpdated(_newLogicContract);\n    }\n\n    function updateBorrowAssetWrapperImpl(address _newLogicContract) external onlyOwner {\n        require(_newLogicContract != address(0), \"INV_C\");\n        borrowAssetWrapperImplementation = _newLogicContract;\n        emit LogicContractUpdated(_newLogicContract);\n    }\n    \n    function updateRewardManager(address _newManager) external onlyOwner {\n        require(_newManager != address(0), \"INV_C\");\n        rewardDistributionManager = _newManager;\n        emit LogicContractUpdated(_newManager);\n    }\n\n    struct NewLendingVaultIRLocalVars {\n        uint256 baseRatePerYear;\n        uint256 multiplierPerYear;\n        uint256 jumpMultiplierPerYear;\n        uint256 optimal;\n        uint256 borrowRateMaxMantissa;\n        uint256 blocksPerYear;\n    }\n\n    /// @dev create interest rate model\n    function createIR(NewLendingVaultIRLocalVars calldata _interestRateVars, address _team)\n        external\n        onlyOwner\n        returns (address ir)\n    {\n        require(address(_team) != address(0), \"inv_t\");\n\n        ir = address(\n            new JumpRateModelV2(\n                _interestRateVars.baseRatePerYear,\n                _interestRateVars.multiplierPerYear,\n                _interestRateVars.jumpMultiplierPerYear,\n                _interestRateVars.optimal,\n                _team,\n                _interestRateVars.borrowRateMaxMantissa,\n                _interestRateVars.blocksPerYear\n            )\n        );\n\n        validInterestRateModels[ir] = true;\n\n        emit NewInterestRateModel(ir, block.timestamp);\n    }\n    \n    /// @dev disable interest rate model\n    function disableIR(address ir) external onlyOwner {\n        require(validInterestRateModels[ir] == true, \"IR_NOT_EXIST\");\n        validInterestRateModels[ir] = false;\n    }\n    \n    struct BorrowLocalVars {\n        IERC20 borrowAsset;\n        uint256 initialExchangeRateMantissa;\n        uint256 reserveFactorMantissa;\n        uint256 collateralFactor;\n        uint256 liquidationFee;\n        IInterestRateModel interestRateModel;\n    }\n\n    struct WrappedAssetLocalVars {\n        IBSWrapperToken wrappedBorrowAsset;\n        IBSWrapperToken wrappedCollateralAsset;\n        IDebtToken debtToken;\n    }\n\n    /// @dev create lending pair with clones\n    function createLendingPairWithProxy(\n        string memory _lendingPairName,\n        string memory _lendingPairSymbol,\n        address _pauseGuardian,\n        IERC20 _collateralAsset,\n        BorrowLocalVars calldata _borrowVars\n    ) external whenNotPaused returns (address newLendingPair) {\n        require(_pauseGuardian != address(0), \"INV_G\");\n        require(address(_collateralAsset) != address(0), \"INV_C\");\n        require(address(_borrowVars.borrowAsset) != address(0), \"INV_B\");\n        require(\n            validInterestRateModels[address(_borrowVars.interestRateModel)] == true,\n            \"INV_I\"\n        );\n\n\n        WrappedAssetLocalVars memory wrappedAssetLocalVars;\n        \n        bytes32 salt = keccak256(abi.encode(_lendingPairName, _lendingPairSymbol, allPairs.length));\n        newLendingPair = lendingPairImplementation.cloneDeterministic(salt);\n\n        // initialize wrapper borrow asset\n        wrappedAssetLocalVars.wrappedBorrowAsset =\n            IBSWrapperToken(\n                initWrapperTokensWithProxy(\n                    borrowAssetWrapperImplementation,\n                    newLendingPair,\n                    address(_borrowVars.borrowAsset),\n                    _lendingPairName,\n                    \"BOR\",\n                    salt\n                )\n            );\n\n        // initialize wrapper collateral asset\n        wrappedAssetLocalVars.wrappedCollateralAsset =\n            IBSWrapperToken(\n                initWrapperTokensWithProxy(\n                    collateralWrapperImplementation,\n                    newLendingPair,\n                    address(_collateralAsset),\n                    _lendingPairName,\n                    \"COL\",\n                    salt\n                )\n            );\n\n        // initialize debt token\n        wrappedAssetLocalVars.debtToken =\n            IDebtToken(\n                initWrapperTokensWithProxy(\n                    debtTokenImplementation,\n                    newLendingPair,\n                    address(_borrowVars.borrowAsset),\n                    _lendingPairName,\n                    \"DEBT\",\n                    salt\n                )\n            );\n\n        DataTypes.BorrowAssetConfig memory borrowConfig =\n            DataTypes.BorrowAssetConfig(\n                _borrowVars.initialExchangeRateMantissa,\n                _borrowVars.reserveFactorMantissa,\n                _borrowVars.collateralFactor,\n                wrappedAssetLocalVars.wrappedBorrowAsset,\n                _borrowVars.liquidationFee,\n                wrappedAssetLocalVars.debtToken\n            );\n\n        // initialize lending pair\n        IBSLendingPair(newLendingPair).initialize(\n            _lendingPairName,\n            _lendingPairSymbol,\n            _borrowVars.borrowAsset,\n            _collateralAsset,\n            borrowConfig,\n            wrappedAssetLocalVars.wrappedCollateralAsset,\n            _borrowVars.interestRateModel,\n            _pauseGuardian\n        );\n        \n        allPairs.push(newLendingPair);\n        emit NewLendingPair(newLendingPair, block.timestamp);\n    }\n\n    function initWrapperTokensWithProxy(\n        address _implementation,\n        address _pair,\n        address _underlying,\n        string memory _lendingPairName,\n        string memory _tokenType,\n        bytes32 _salt\n    ) internal returns (address wrapper) {\n        wrapper = _implementation.cloneDeterministic(_salt);\n\n        initializeWrapperTokens(\n            _pair,\n            IBSWrapperToken(wrapper),\n            IERC20Details(_underlying),\n            _lendingPairName,\n            _tokenType\n        );\n    }\n\n    function initializeWrapperTokens(\n        address _pair,\n        IBSWrapperToken _wrapperToken,\n        IERC20Details _underlying,\n        string memory _lendingPairName,\n        string memory _tokenType\n    ) internal {\n        bytes memory name = abi.encodePacked(_lendingPairName);\n        name = abi.encodePacked(name, \"-PAIR-\", _tokenType);\n        bytes memory symbol = abi.encodePacked(_lendingPairName);\n        symbol = abi.encodePacked(name, _tokenType);\n        // initialize wrapperToken\n        IBSWrapperToken(_wrapperToken).initialize(\n            _pair,\n            address(_underlying),\n            string(name),\n            string(symbol),\n            IRewardDistributorManager(rewardDistributionManager)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/interest/JumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title JumpRateModelV2\n/// @author\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract JumpRateModelV2 {\n    event NewInterestParams(\n        uint256 baseRatePerBlock,\n        uint256 multiplierPerBlock,\n        uint256 jumpMultiplierPerBlock,\n        uint256 kink\n    );\n\n    /// @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n    address public owner;\n\n    /// @notice The approximate number of blocks per year that is assumed by the interest rate model\n    uint256 public immutable blocksPerYear;\n\n    /// @notice The multiplier of utilization rate that gives the slope of the interest rate\n    uint256 public multiplierPerBlock;\n\n    /// @notice The base interest rate which is the y-intercept when utilization rate is 0\n    uint256 public baseRatePerBlock;\n\n    /// @notice The multiplierPerBlock after hitting a specified utilization point\n    uint256 public jumpMultiplierPerBlock;\n\n    /// @notice The utilization point at which the jump multiplier is applied\n    uint256 public kink;\n\n    /// @dev Maximum borrow rate that can ever be applied per second\n    uint256 internal immutable borrowRateMaxMantissa;\n\n    /// @notice Construct an interest rate model\n    /// @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n    /// @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n    /// @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param owner_ The address of the owner, i.e. which has the ability to update parameters directly\n    /// @param borrowRateMaxMantissa_ maximum borrow rate per second\n    /// @param blocksPerYear_ the number of blocks on the chain per year\n    constructor(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        address owner_,\n        uint256 borrowRateMaxMantissa_,\n        uint256 blocksPerYear_\n    ) {\n        require(baseRatePerYear > 0, \"invalid base rate\");\n        require(multiplierPerYear > 0, \"invalid multiplier per year\");\n        require(jumpMultiplierPerYear > 0, \"invalid jump multiplier per year\");\n        require(kink_ > 0, \"invalid kink\");\n        require(owner_ != address(0), \"invalid owner\");\n        require(borrowRateMaxMantissa_ > 0, \"invalid borrow rate max\");\n        require(blocksPerYear_ > 0, \"invalid blocks per year\");\n\n        owner = owner_;\n        borrowRateMaxMantissa = borrowRateMaxMantissa_;\n        blocksPerYear = blocksPerYear_;\n        updateJumpRateModelInternal(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_,\n            blocksPerYear_\n        );\n    }\n\n    /// @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n    /// @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n    /// @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n    /// @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external {\n        require(msg.sender == owner, \"only the owner may call this function.\");\n        require(baseRatePerYear > 0, \"invalid base rate\");\n        require(multiplierPerYear > 0, \"invalid multiplier per year\");\n        require(jumpMultiplierPerYear > 0, \"invalid jump multiplier per year\");\n        require(kink_ > 0, \"invalid kink\");\n\n        updateJumpRateModelInternal(\n            baseRatePerYear,\n            multiplierPerYear,\n            jumpMultiplierPerYear,\n            kink_,\n            blocksPerYear\n        );\n    }\n\n    /// @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @param reserves The amount of reserves in the market (currently unused)\n    /// @return The utilization rate as a mantissa between [0, 1e18]\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n\n        return (borrows * (1e18)) / (cash + borrows - reserves);\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @param reserves The amount of reserves in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves);\n\n        if (util <= kink) {\n            return (util * multiplierPerBlock) / 1e18 + baseRatePerBlock;\n        } else {\n            uint256 normalRate = (kink * multiplierPerBlock) / 1e18 + baseRatePerBlock;\n            uint256 excessUtil = util - kink;\n            return (excessUtil * jumpMultiplierPerBlock) / 1e18 + normalRate;\n        }\n    }\n\n    /**\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @param reserves The amount of reserves in the market\n    /// @param reserveFactorMantissa The current reserve factor for the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) public view returns (uint256) {\n        uint256 oneMinusReserveFactor = uint256(1e18) - reserveFactorMantissa;\n        uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / 1e18;\n        return (utilizationRate(cash, borrows, reserves) * rateToPool) / 1e18;\n    }\n\n    /// @notice Internal function to update the parameters of the interest rate model\n    /// @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n    /// @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n    /// @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    function updateJumpRateModelInternal(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_,\n        uint256 blocksPerYear_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear / blocksPerYear_;\n        multiplierPerBlock = (multiplierPerYear * 1e18) / (blocksPerYear_ * kink_);\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear_;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n\n    /// @notice Calculates the current borrow rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @param reserves The amount of reserves in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256) {\n        uint256 borrowRateMantissa = getBorrowRateInternal(cash, borrows, reserves);\n        if (borrowRateMantissa > borrowRateMaxMantissa) {\n            return borrowRateMaxMantissa;\n        } else {\n            return borrowRateMantissa;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/LendingPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./math/Exponential.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IBSVault.sol\";\nimport \"./interfaces/IBSLendingPair.sol\";\nimport \"./interfaces/IBSWrapperToken.sol\";\nimport \"./interfaces/IDebtToken.sol\";\nimport \"./interfaces/IPriceOracleAggregator.sol\";\nimport \"./DataTypes.sol\";\nimport \"./util/Initializable.sol\";\nimport \"./token/IERC20Details.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title LendingPair\n/// @author @samparsky\n/// @notice\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract LendingPair is IBSLendingPair, Exponential, Initializable {\n    using SafeERC20 for IERC20;\n    using DataTypes for DataTypes.BorrowAssetConfig;\n\n    enum Actions {Deposit, Borrow}\n\n    /// @dev lending pair name\n    string public name;\n\n    /// @dev lending pair symbol\n    string public symbol;\n\n    /// @dev version\n    uint256 public constant VERSION = 0x1;\n\n    /// @notice where the tokens are stored\n    IBSVault public immutable vault;\n\n    /// @notice protocol liquidation fee percent in 1e18\n    uint256 public immutable protocolLiquidationFeeShare;\n\n    /// @notice The interest rate model for the borrow asset\n    IInterestRateModel public interestRate;\n\n    /// @notice The price oracle for the assets\n    IPriceOracleAggregator public immutable override oracle;\n\n    /// @notice The address to withdraw fees to\n    address public immutable feeWithdrawalAddr;\n\n    /// @dev borrow asset underlying decimal\n    uint8 private _borrowAssetUnderlyingDecimal;\n\n    /// @dev collateral asset underlying decimal\n    uint8 private _collateralAssetUnderlyingDecimal;\n\n    /// @dev initialExchangeRateMantissa Initial exchange rate used when minting\n    uint256 internal initialExchangeRateMantissa;\n\n    /// @dev Fraction of interest currently set aside for reserves\n    uint256 private reserveFactorMantissa;\n\n    /// @dev Block number that interest was last accrued at\n    uint256 private accrualBlockNumber;\n\n    /// @dev Accumulator of the total earned interest rate since the opening of the market\n    uint256 public override borrowIndex;\n\n    /// @notice Total amount of reserves of the underlying held in this market\n    uint256 public override totalReserves;\n\n    /// @dev The amount of collateral required for a borrow position in 1e18\n    uint256 public collateralFactor;\n\n    /// @notice liquidation fee in 1e18\n    uint256 public liquidationFee;\n\n    /// @dev liquidation fee precision\n    uint256 private constant PRECISION = 1e18;\n\n    /// @notice the address that can pause borrow & deposits of assets\n    address public pauseGuardian;\n\n    /// @notice The pair borrow asset\n    IERC20 public override asset;\n\n    /// @notice The pair collateral asset\n    IERC20 public override collateralAsset;\n\n    /// @notice The wrapper token for the borrow asset\n    IBSWrapperToken public override wrapperBorrowedAsset;\n\n    /// @notice The wrapper token for the collateral asset\n    IBSWrapperToken public override wrappedCollateralAsset;\n\n    /// @notice The wrapper token for debt\n    IDebtToken public override debtToken;\n\n    /// @notice Mapping of account addresses to their interest interest index\n    mapping(address => uint256) public override accountInterestIndex;\n\n    /// @notice Mapping of action to pause status\n    mapping(Actions => bool) public pauseStatus;\n\n    modifier whenNotPaused(Actions action) {\n        require(pauseStatus[action] == false, \"PAUSED\");\n        _;\n    }\n\n    modifier onlyPauseGuardian() {\n        require(msg.sender == pauseGuardian, \"O_G\");\n        _;\n    }\n\n    constructor(\n        IBSVault _vault,\n        IPriceOracleAggregator _oracle,\n        address _feeWithdrawalAddr,\n        uint256 _procotolLiquidationFeeShare\n    ) {\n        // invalid vault or oracle\n        require(address(_vault) != address(0), \"IV0\");\n        // invalid vault or oracle\n        require(address(_oracle) != address(0), \"IV0\");\n        // invalid fee withdrawal addr\n        require(_feeWithdrawalAddr != address(0), \"IVWA\");\n\n        vault = _vault;\n        oracle = _oracle;\n        feeWithdrawalAddr = _feeWithdrawalAddr;\n        protocolLiquidationFeeShare = _procotolLiquidationFeeShare;\n    }\n\n    /// @notice Initialize function\n    /// @param _name for lending pair\n    /// @param _symbol for lending pair\n    /// @param _asset borrow asset  \n    /// @param _collateralAsset pair collateral\n    /// @param _wrappedCollateralAsset wrapped token minted when depositing collateral asset\n    /// @param _pauseGuardian pause guardian address\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        IERC20 _asset,\n        IERC20 _collateralAsset,\n        DataTypes.BorrowAssetConfig calldata borrowConfig,\n        IBSWrapperToken _wrappedCollateralAsset,\n        IInterestRateModel _interestRate,\n        address _pauseGuardian\n    ) external override initializer {\n        // invalid asset or collateral asset\n        require(address(_asset) != address(0) && address(_collateralAsset) != address(0), \"IAC\");\n        // invalid pause guardian\n        require(_pauseGuardian != address(0), \"IVP\");\n        // validate wrapped collateral asset owner\n        require(_wrappedCollateralAsset.owner() == address(this), \"IVWC\");\n        // interest rate model\n        require(address(_interestRate) != address(0), \"IVIR\");\n        // en\n        require(borrowConfig.liquidationFee > 0, \"INLF\");\n        // validate borrow config\n        borrowConfig.validBorrowAssetConfig(address(this));\n\n        name = _name;\n        symbol = _symbol;\n        pauseGuardian = _pauseGuardian;\n        asset = _asset;\n        collateralAsset = _collateralAsset;\n        interestRate = _interestRate;\n        borrowIndex = mantissaOne;\n\n        initialExchangeRateMantissa = borrowConfig.initialExchangeRateMantissa;\n        reserveFactorMantissa = borrowConfig.reserveFactorMantissa;\n        collateralFactor = borrowConfig.collateralFactor;\n        liquidationFee = borrowConfig.liquidationFee;\n        wrapperBorrowedAsset = borrowConfig.wrappedBorrowAsset;\n        debtToken = borrowConfig.debtToken;\n\n        wrappedCollateralAsset = _wrappedCollateralAsset;\n\n        _borrowAssetUnderlyingDecimal = IERC20Details(address(asset)).decimals();\n        _collateralAssetUnderlyingDecimal = IERC20Details(address(collateralAsset)).decimals();\n\n        emit Initialized(address(this), address(_asset), address(_collateralAsset), _pauseGuardian);\n    }\n\n    /// @dev pause actions in the lending pair\n    function pause(Actions action) external onlyPauseGuardian {\n        pauseStatus[action] = true;\n        emit ActionPaused(uint8(action), block.timestamp);\n    }\n\n    /// @dev unpause actions in lending pair\n    function unpause(Actions action) external onlyPauseGuardian {\n        pauseStatus[action] = false;\n        emit ActionUnPaused(uint8(action), block.timestamp);\n    }\n\n    /// @notice deposit allows a user to deposit underlying collateral from vault\n    /// @param _tokenRecipient address to credit the wrapped collateral shares\n    /// @param _amount is the amount of underlying collateral asset being deposited\n    function depositCollateral(address _tokenRecipient, uint256 _amount)\n        public\n        override\n        whenNotPaused(Actions.Deposit)\n    {\n        uint256 vaultShareAmount = vault.toShare(collateralAsset, _amount, false);\n\n        vault.transfer(collateralAsset, msg.sender, address(this), vaultShareAmount);\n        // mint receipient vault share amount\n        wrappedCollateralAsset.mint(_tokenRecipient, vaultShareAmount);\n\n        emit Deposit(\n            address(this),\n            address(collateralAsset),\n            _tokenRecipient,\n            msg.sender,\n            vaultShareAmount\n        );\n    }\n\n    /// @dev the user should initially have deposited in the vault\n    /// transfer appropriate amount of underlying from msg.sender to the LendingPair\n    /// @param _tokenRecipient whom to credit the wrapped tokens\n    /// @param _amount is the amount of underlying borrow asset being deposited\n    function depositBorrowAsset(address _tokenRecipient, uint256 _amount)\n        public\n        override\n        whenNotPaused(Actions.Deposit)\n    {\n        require(_tokenRecipient != address(0), \"IDB\");\n        uint256 vaultShareAmount = vault.toShare(asset, _amount, false);\n\n        // retrieve exchange rate\n        uint256 exchangeRateMantissa = exchangeRateCurrent();\n        // We get the current exchange rate and calculate the number of wrapper token to be minted:\n        // mintTokens = _amount / exchangeRate\n        uint256 mintTokens =\n            divScalarByExpTruncate(_amount, Exp({mantissa: exchangeRateMantissa}));\n\n        // transfer appropriate amount of DAI from msg.sender to the Vault\n        vault.transfer(asset, msg.sender, address(this), vaultShareAmount);\n\n        // mint appropriate wrapped tokens\n        wrapperBorrowedAsset.mint(_tokenRecipient, mintTokens);\n\n        emit Deposit(\n            address(this),\n            address(asset),\n            _tokenRecipient,\n            msg.sender,\n            vaultShareAmount\n        );\n    }\n\n    /// @param _amountToBorrow is the amount of the borrow asset vault shares the user wants to borrow\n    /// @param _debtOwner this should be the msg.sender or address that delegates credit to the msg.sender\n    /// @dev we use normalized amounts to calculate the\n    function borrow(uint256 _amountToBorrow, address _debtOwner) public whenNotPaused(Actions.Borrow) {\n        require(_debtOwner != address(0), \"INV_DEBT_OWNER\");\n        // save on sload\n        uint8 __borrowAssetUnderlyingDecimal = _borrowAssetUnderlyingDecimal;\n        IERC20 __asset = asset;\n\n        uint256 borrowedTotalWithInterest = borrowBalanceCurrent(_debtOwner);\n        uint256 currentBorrowAssetPrice = oracle.getPriceInUSD(__asset);\n        uint256 borrowedTotalInUSDNormalized =\n            normalize(borrowedTotalWithInterest, __borrowAssetUnderlyingDecimal) *\n                currentBorrowAssetPrice;\n        uint256 borrowLimitInUSDNormalized =\n            normalize(getBorrowLimit(_debtOwner), _collateralAssetUnderlyingDecimal) *\n                getPriceOfCollateral();\n        uint256 borrowAmountAllowedInUSDNormalized =\n            borrowLimitInUSDNormalized - borrowedTotalInUSDNormalized;\n        // borrow amount in usd normalized\n        uint256 borrowAmountInUSDNormalized =\n            normalize(_amountToBorrow, __borrowAssetUnderlyingDecimal) * currentBorrowAssetPrice;\n        // require the amount being borrowed is less than\n        // or equal to the amount they are aloud to borrow\n        require(\n            borrowAmountAllowedInUSDNormalized >= borrowAmountInUSDNormalized,\n            \"BORROWING_MORE_THAN_ALLOWED\"\n        );\n\n        uint256 amountOfSharesToBorrow = vault.toShare(__asset, _amountToBorrow, false);\n        // mint debt tokens to _debtOwner account\n        debtToken.mint(_debtOwner, msg.sender, _amountToBorrow);\n        // set interest index\n        accountInterestIndex[_debtOwner] = borrowIndex;\n        // transfer borrow asset to borrower\n        vault.transfer(__asset, address(this), msg.sender, amountOfSharesToBorrow);\n\n        emit Borrow(msg.sender, _amountToBorrow);\n    }\n\n    /// @notice Sender repays their own borrow\n    /// @param _repayAmount The amount of borrow asset to repay represented in underlying\n    /// @param _beneficiary address to repay loan position\n    function repay(uint256 _repayAmount, address _beneficiary) public {\n        require(_beneficiary != address(0), \"INV_BENEFICIARY\");\n\n        // We fetch the amount the borrower owes, with accumulated interest\n        uint256 accountBorrows = borrowBalanceCurrent(_beneficiary);\n\n        // require the borrower cant pay more than they owe\n        require(_repayAmount <= accountBorrows, \"MORE_THAN_OWED\");\n\n        uint256 repayAmount;\n\n        if (_repayAmount == 0) {\n            repayAmount = accountBorrows;\n        } else {\n            repayAmount = _repayAmount;\n        }\n\n        // convert repayAmount to share and round up\n        uint256 repayAmountInShares = vault.toShare(asset, repayAmount, true);\n\n        require(\n            vault.balanceOf(asset, msg.sender) >= repayAmountInShares,\n            \"NOT_ENOUGH_BALANCE\"\n        );\n\n        // transfer the borrow asset from the borrower to LendingPair\n        vault.transfer(asset, msg.sender, address(this), repayAmountInShares);\n\n        // burn the repay token amount\n        debtToken.burn(_beneficiary, repayAmount);\n\n        // set the account interest index\n        accountInterestIndex[_beneficiary] = borrowIndex;\n\n\n        emit Repay(\n            address(this),\n            address(asset),\n            _beneficiary,\n            msg.sender,\n            repayAmount\n        );\n    }\n\n    struct RedeemLocalVars {\n        uint256 exchangeRateMantissa;\n        uint256 amountOfTokensToRedeem;\n        uint256 amountOfSharesToRedeem;\n        uint256 amountOfTokens;\n    }\n\n    /// @notice Allows a user to redeem their Wrapper Token for the appropriate amount of underlying asset\n    /// @param _to Address to send the underlying tokens to\n    /// @param _amount of wrapper token to redeem\n    function redeem(address _to, uint256 _amount) public override {\n        require(_to != address(0), \"INV_TO\");\n\n        RedeemLocalVars memory vars;\n\n        // retreive current exchange rate\n        vars.exchangeRateMantissa = exchangeRateCurrent();\n\n        if (_amount == 0) {\n            vars.amountOfTokens = wrapperBorrowedAsset.balanceOf(msg.sender);\n        } else {\n            vars.amountOfTokens = _amount;\n        }\n\n        // this is tokens\n        vars.amountOfTokensToRedeem = mulScalarTruncate(\n            Exp({mantissa: vars.exchangeRateMantissa}),\n            vars.amountOfTokens\n        );\n\n        // convert it to shares\n        vars.amountOfSharesToRedeem = vault.toShare(asset, vars.amountOfTokensToRedeem, false);\n\n        // ensure the lending pair has enough borrow asset balance\n        require(vault.balanceOf(asset, address(this)) >= vars.amountOfSharesToRedeem, \"NOT_ENOUGH_BALANCE\");\n\n        // reverts if the user doesn't have enough tokens\n        wrapperBorrowedAsset.burn(msg.sender, vars.amountOfTokens);\n\n        // transfer the quantity of shares to the user\n        vault.transfer(asset, address(this), _to, vars.amountOfSharesToRedeem);\n\n        emit Redeem(address(this), address(asset), msg.sender, _to, vars.amountOfSharesToRedeem, vars.amountOfTokens);\n    }\n    \n    uint8 private constant BORROW_ASSET_DEPOSIT = 1;\n    uint8 private constant REPAY = 2;\n    uint8 private constant BORROW = 3;\n    uint8 private constant REDEEM = 4;\n    uint8 private constant WITHDRAW_COLLATERAL = 5;\n\n    uint8 private constant COLLATERAL_DEPOSIT = 10;\n    uint8 private constant VAULT_DEPOSIT = 11;\n    uint8 private constant VAULT_WITHDRAW = 12;\n    uint8 private constant VAULT_TRANSFER = 13;\n    uint8 private constant VAULT_APPROVE_CONTRACT = 14;\n\n    function warp(\n        uint8[] calldata actions,\n        bytes[] calldata data\n    ) external {\n        require(actions.length == data.length, \"INV\");\n\n        for (uint8 i = 0; i < actions.length;  i++) {\n            uint8 action = actions[i];\n            if (action == BORROW_ASSET_DEPOSIT) {\n                (address receipient, uint256 vaultAmount) = abi.decode(data[i], (address, uint256));\n                depositBorrowAsset(receipient, vaultAmount);\n            } else if (action == COLLATERAL_DEPOSIT) {\n                (address receipient, uint256 amount) = abi.decode(data[i], (address, uint256));\n                depositCollateral(receipient, amount);\n            } else if (action == REPAY) {\n                (uint256 amount, address beneficiary) = abi.decode(data[i], (uint256, address));\n                repay(amount, beneficiary);\n            } else if (action == BORROW) {\n                (address debtOwner, uint256 amount) = abi.decode(data[i], (address, uint256));\n                borrow(amount, debtOwner);\n            } else if (action == REDEEM) {\n                (address receipient, uint256 amount) = abi.decode(data[i], (address, uint256));\n                redeem(receipient, amount);\n            } else if (action == WITHDRAW_COLLATERAL) {\n                (uint256 amount) = abi.decode(data[i], (uint256));\n                withdrawCollateral(amount);\n            } else if (action == VAULT_DEPOSIT) {\n                (address token, address to, uint256 amount) = abi.decode(data[i], (address, address, uint256));\n                vault.deposit(IERC20(token), msg.sender, to, amount);\n            } else if (action == VAULT_WITHDRAW) {\n                (address token, address to, uint256 amount) = abi.decode(data[i], (address, address, uint256));\n                vault.withdraw(IERC20(token), msg.sender, to, amount);\n            } else if (action == VAULT_TRANSFER) {\n                (address token, address to, uint256 amount) = abi.decode(data[i], (address, address, uint256));\n                vault.transfer(IERC20(token), msg.sender, to, amount);\n            } else if (action == VAULT_APPROVE_CONTRACT) {\n                (\n                    address _user,\n                    address _contract,\n                    bool status,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(data[i], (address, address, bool, uint8, bytes32, bytes32));\n                vault.approveContract(_user, _contract, status, v, r, s);\n            }\n        }\n    }\n\n    /// @notice calculateFee is used to calculate the fee earned\n    /// @param _amount is a uint representing the full amount earned as interest\n    function calculateLiquidationFee(uint256 _amount) public view returns (uint256 fee) {\n        fee = (_amount * liquidationFee) / PRECISION;\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public returns (uint256) {\n        accrueInterest();\n\n        // convert amount to underlying\n        uint256 currentTotalSupply = wrapperBorrowedAsset.totalSupply();\n\n        if (currentTotalSupply == 0) {\n            // If there are no tokens minted: exchangeRate = initialExchangeRate\n            return initialExchangeRateMantissa;\n        } else {\n            // Otherwise: exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            uint256 totalCash = getCashPrior(); // get contract asset balance\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n\n            // calculate total value held by contract plus owed to contract\n            // uint totalBorrows = totalBorrows();\n            cashPlusBorrowsMinusReserves = totalCash + totalBorrows() - totalReserves;\n\n            // calculate exchange rate\n            exchangeRate = getExp(cashPlusBorrowsMinusReserves, currentTotalSupply);\n\n            return (exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice getCashPrior is a view funcion that returns the balance of all held borrow asset\n    function getCashPrior() public view returns (uint256) {\n        uint256 currentBalance = vault.balanceOf(asset, address(this));\n        if (currentBalance > 0 ) {\n            return vault.toUnderlying(asset, currentBalance);\n        }\n        return currentBalance;\n    }\n\n    /// @notice Total amount of outstanding borrows of the asset in this market\n    function totalBorrows() public view returns (uint256) {\n        return debtToken.totalSupply();\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    /// up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public {\n        // remember the initial block number\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\n\n        // short-circuit accumulating 0 interest\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            emit InterestShortCircuit(currentBlockNumber);\n            return;\n        }\n\n        // read the previous values out of storage\n        uint256 cashPrior = getCashPrior();\n        uint256 borrowsPrior = totalBorrows();\n        uint256 reservesPrior = totalReserves;\n\n        uint256 borrowIndexPrior = borrowIndex;\n\n        // calculate the current borrow interest rate\n        uint256 borrowRateMantissa =\n            interestRate.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n        // Calculate the number of blocks elapsed since the last accrual\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n        // Calculate the interest accumulated into borrows and reserves and the new index:\n        Exp memory simpleInterestFactor;\n        uint256 interestAccumulated;\n        uint256 totalReservesNew;\n        uint256 borrowIndexNew;\n\n        // simpleInterestFactor = borrowRate * blockDelta\n        simpleInterestFactor = mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\n\n        // interestAccumulated = simpleInterestFactor * totalBorrows\n        interestAccumulated = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n\n        // totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n        totalReservesNew = mulScalarTruncateAddUInt(\n            Exp({mantissa: reserveFactorMantissa}),\n            interestAccumulated,\n            reservesPrior\n        );\n\n        // borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n        borrowIndexNew = mulScalarTruncateAddUInt(\n            simpleInterestFactor,\n            borrowIndexPrior,\n            borrowIndexPrior\n        );\n\n        // Write the previously calculated values into storage\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        // increase total borrows\n        // totalBorrowsNew = interestAccumulated + totalBorrows\n        debtToken.increaseTotalDebt(interestAccumulated);\n\n        totalReserves = totalReservesNew;\n\n        emit InterestAccrued(\n            address(this),\n            accrualBlockNumber,\n            borrowIndex,\n            // total borrows\n            borrowsPrior + interestAccumulated,\n            totalReserves\n        );\n    }\n\n    /**\n    @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance \n            using the updated borrowIndex\n    @param _account The address whose balance should be calculated after updating borrowIndex\n    @return The calculated balance\n    **/\n    function borrowBalanceCurrent(address _account) public returns (uint256) {\n        accrueInterest();\n        return borrowBalancePrior(_account);\n    }\n\n    function borrowBalancePrior(address _account) public view override returns (uint256 balance) {\n        uint256 principalTimesIndex;\n        // Get borrowBalance and borrowIndex\n        uint256 principal = debtToken.principal(_account);\n        // If borrowBalance = 0 then borrowIndex is likely also 0.\n        // Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n        if (principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowInterestIndex = accountInterestIndex[_account];\n        // Calculate new borrow balance using the interest index:\n        // recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n        principalTimesIndex = principal * borrowIndex;\n\n        balance = principalTimesIndex / borrowInterestIndex;\n    }\n\n    /// @notice withdrawFees to the feeWithdrawalAddr\n    /// @param _toWithdraw is the amount of a reservers being withdrawn in tokens\n    /// @dev this function can be called by anyone\n    function withdrawFees(uint256 _toWithdraw) external override {\n        require(totalReserves >= _toWithdraw, \"NOT_ENOUGH_BALANCE\");\n\n        totalReserves = totalReserves - _toWithdraw;\n        uint256 shareAmount = vault.toShare(\n            asset,\n            _toWithdraw,\n            false\n        );\n        vault.transfer(asset, address(this), feeWithdrawalAddr, shareAmount);\n\n        emit ReserveWithdraw(feeWithdrawalAddr, _toWithdraw);\n    }\n\n    ////////////////////////////////\n    // Collateral Actions\n    ///////////////////////////////\n\n    function withdrawCollateral(uint256 _amount) public {\n        uint256 amount;\n\n        uint256 maxAmount = getMaxWithdrawAllowed(msg.sender);\n\n        if (_amount == 0) {\n            amount = maxAmount;\n        } else {\n            amount = _amount;\n        }\n\n        // require the availible value of the collateral locked in this contract the user has\n        // is greater than or equal to the amount being withdrawn\n        require(maxAmount >= amount, \"EXCEEDS_ALLOWED\");\n        // subtract withdrawn amount from amount stored\n        // reverts if the user doesn't have enough balance\n        wrappedCollateralAsset.burn(msg.sender, amount);\n\n        // transfer them their token\n        vault.transfer(collateralAsset, address(this), msg.sender, amount);\n\n        emit WithdrawCollateral(msg.sender, amount);\n    }\n\n    /// @notice collateralOfAccount is a view function to retreive an accounts collateral\n    /// @param _account is the address of the account being looked up\n    function collateralOfAccount(address _account) public view override returns (uint256) {\n        return wrappedCollateralAsset.balanceOf(_account);\n    }\n\n    /// @notice Figures out how much of a given collateral an account is allowed to withdraw\n    /// @param _account is the account being checked\n    /// @dev this function runs calculations to accrue interest for an up to date amount\n    function getMaxWithdrawAllowed(address _account) public override returns (uint256 maxWithdrawAllowed) {\n        // save on sload\n        uint8 __collateralAssetUnderlyingDecimal = _collateralAssetUnderlyingDecimal;\n\n        uint256 normalizedBorrowedAmountTotal =\n            normalize(borrowBalanceCurrent(_account), _borrowAssetUnderlyingDecimal);\n\n        uint256 currentCollateralValueInUSD = getPriceOfCollateral();\n\n        uint256 borrowedTotalNormalizedAmountInUSD =\n            getPriceOfToken(asset, normalizedBorrowedAmountTotal);\n        uint256 collateralValueNormalizedInUSD =\n            normalize(\n                getTotalAvailableCollateralValue(_account),\n                __collateralAssetUnderlyingDecimal\n            ) * currentCollateralValueInUSD;\n        uint256 requiredCollateralNormalizedInUSD =\n            calcCollateralRequired(borrowedTotalNormalizedAmountInUSD);\n\n        if (collateralValueNormalizedInUSD < requiredCollateralNormalizedInUSD) {\n            return 0;\n        }\n\n        // remaining collateral denormalized\n        uint256 leftoverCollateral =\n            denormalize(\n                collateralValueNormalizedInUSD - requiredCollateralNormalizedInUSD,\n                __collateralAssetUnderlyingDecimal\n            );\n\n        maxWithdrawAllowed = vault.toShare(collateralAsset, leftoverCollateral / currentCollateralValueInUSD, false);\n    }\n\n    /// @notice getTotalAvailableCollateralValueInUSD returns the total availible collaeral value for an account in USD\n    /// @param _account is the address whos collateral is being retreived\n    /// @dev this function runs calculations to accrue interest for an up to date amount\n    function getTotalAvailableCollateralValueInUSD(address _account) public view returns (uint256) {\n        return\n            getPriceOfToken(\n                collateralAsset,\n                // convert the amount of collateral to underlying amount\n                vault.toUnderlying(collateralAsset, collateralOfAccount(_account))\n            );\n    }\n\n    /// @notice getTotalAvailableCollateralValue returns the total availible collaeral value for an account\n    /// @param _account is the address whos collateral is being retreived\n    /// @dev this function runs calculations to accrue interest for an up to date amount\n    function getTotalAvailableCollateralValue(address _account) public view returns (uint256) {\n        // convert the amount of collateral to underlying amount\n        return vault.toUnderlying(collateralAsset, collateralOfAccount(_account));\n    }\n\n    /// @dev returns price of collateral in usd\n    function getPriceOfCollateral() public view returns (uint256) {\n        return oracle.getPriceInUSD(collateralAsset);\n    }\n\n    /// @dev returns price of collateral in usd\n    function getPriceOfBorrowAsset() external view returns (uint256) {\n        return oracle.getPriceInUSD(asset);\n    }\n\n    /// @notice getPriceOfToken returns price of token in usd\n    /// @param _token this is the price of the token\n    /// @param _amount this is the amount of tokens\n    function getPriceOfToken(IERC20 _token, uint256 _amount) public view returns (uint256) {\n        return oracle.getPriceInUSD(_token) * _amount;\n    }\n\n    /// @notice calcBorrowLimit is used to calculate the borrow limit for an account \n    /// based on the input value of their collateral\n    /// @param _collateralValueInUSD is the USD value of the users collateral\n    function calcBorrowLimit(uint256 _collateralValueInUSD) public view override returns (uint256) {\n        return (_collateralValueInUSD * PRECISION) / collateralFactor;\n    }\n\n    /// @notice calcCollateralRequired returns the amount of collateral needed for an input borrow value\n    /// @param _borrowAmount is the input borrow amount\n    function calcCollateralRequired(uint256 _borrowAmount) public view returns (uint256) {\n        return (_borrowAmount * collateralFactor) / PRECISION;\n    }\n\n    /// @notice getBorrowLimit returns the borrow limit for an account\n    /// @param _account is the input account address\n    /// @dev this calculation uses current values for calculations\n    function getBorrowLimitInUSD(address _account) public view returns (uint256) {\n        uint256 availibleCollateralValue = getTotalAvailableCollateralValueInUSD(_account);\n        return calcBorrowLimit(availibleCollateralValue);\n    }\n\n    /// @notice getBorrowLimit returns the borrow limit for an account\n    /// @param _account is the input account address\n    /// @dev this calculation uses current values for calculations\n    function getBorrowLimit(address _account) public view returns (uint256) {\n        uint256 availibleCollateralValue = getTotalAvailableCollateralValue(_account);\n\n        return calcBorrowLimit(availibleCollateralValue);\n    }\n\n    function liquidate(address _borrower) external {\n        // require the liquidator is not also the borrower\n        require(msg.sender != _borrower, \"NOT_LIQUIDATE_SELF\");\n\n        uint256 currentBorrowAssetPriceInUSD = oracle.getPriceInUSD(asset);\n        uint256 priceOfCollateralInUSD = getPriceOfCollateral();\n\n        uint256 borrowedTotalWithInterest = borrowBalanceCurrent(_borrower);\n        uint256 borrowedTotalInUSDNormalized = \n            normalize(borrowedTotalWithInterest, _borrowAssetUnderlyingDecimal) *\n                currentBorrowAssetPriceInUSD;\n        uint256 borrowLimitInUSDNormalized =\n            normalize(getBorrowLimit(_borrower), _collateralAssetUnderlyingDecimal) *\n                priceOfCollateralInUSD;\n\n        // check if the borrow is less than the borrowed amount\n        if (borrowLimitInUSDNormalized <= borrowedTotalInUSDNormalized) {\n            // liquidation fee\n            uint256 totalLiquidationFee = calculateLiquidationFee(borrowedTotalWithInterest);\n            uint256 protocolFeeShareValue =\n                (totalLiquidationFee * protocolLiquidationFeeShare) / PRECISION;\n\n            _repayLiquidatingLoan(\n                _borrower,\n                msg.sender,\n                borrowedTotalWithInterest,\n                borrowedTotalWithInterest + protocolFeeShareValue\n            );\n\n            // Clear the borrowers interest rate index\n            accountInterestIndex[_borrower] = 0;\n            // add protocol liquidaiton fee amount to reserves\n            totalReserves = totalReserves + protocolFeeShareValue;\n\n            // convert borrowedTotal to usd\n            uint256 borrowedTotalInUSD =\n                currentBorrowAssetPriceInUSD * (borrowedTotalWithInterest + totalLiquidationFee);\n\n            // @TODO ceil!?\n            uint256 amountOfCollateralToLiquidate = (borrowedTotalInUSD * _collateralAssetUnderlyingDecimal) / (priceOfCollateralInUSD * _borrowAssetUnderlyingDecimal);\n            uint256 amountOfCollateralToLiquidateInVaultShares =\n                vault.toShare(collateralAsset, amountOfCollateralToLiquidate, true);\n            \n            _liquidate(_borrower, msg.sender, amountOfCollateralToLiquidateInVaultShares);\n        }\n    }\n\n    /// @dev _repayLiquidatingLoan\n    /// @param _borrower is the address of the borrower who took out the loan\n    /// @param _liquidator is the address of the account who is liquidating the loan\n    /// @param _borrowedAmount is the amount of StableCoin being repayed + fee\n    /// @dev\n    function _repayLiquidatingLoan(\n        address _borrower,\n        address _liquidator,\n        uint256 _borrowedAmount,\n        uint256 _borrowedAmountPlusFee\n    ) internal {\n        // borrowed amount + liquidation fee\n        uint256 amountInShares = vault.toShare(asset, _borrowedAmountPlusFee, true);\n        // repay the liquidated position\n        vault.transfer(asset, _liquidator, address(this), amountInShares);\n        // burn borrower debt\n        debtToken.burn(_borrower, _borrowedAmount);\n    }\n\n    /// @dev _liquidate is a function to liquidate a user\n    /// @param _account is the address of the account being liquidated\n    /// @param _liquidator is the address of the account doing the liquidating who receives the collateral\n    function _liquidate(\n        address _account,\n        address _liquidator,\n        uint256 amountOfCollateralToLiquidateInVaultShares\n    ) internal {\n        uint accountCollateralBalance = wrappedCollateralAsset.balanceOf(_account);\n        // incase the value of the collateral drops\n        // faster than liquidate\n        if (amountOfCollateralToLiquidateInVaultShares > accountCollateralBalance) {\n            amountOfCollateralToLiquidateInVaultShares = accountCollateralBalance;\n        }\n        \n        // reset the borrowers collateral tracker\n        wrappedCollateralAsset.burn(_account, amountOfCollateralToLiquidateInVaultShares);\n\n        // transfer the collateral tokens to the liquidator\n        vault.transfer(\n            collateralAsset,\n            address(this),\n            _liquidator,\n            amountOfCollateralToLiquidateInVaultShares\n        );\n\n        emit Liquidate(\n            address(this),\n            address(collateralAsset),\n            address(_account),\n            amountOfCollateralToLiquidateInVaultShares,\n            _liquidator\n        );\n    }\n\n    /// @notice getBlockNumber allows for easy retrieval of block number\n    /// @return block number\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external view returns (uint256) {\n        return\n            interestRate.getBorrowRate(\n                getCashPrior(),\n                debtToken.totalSupply(),\n                totalReserves\n            );\n    }\n\n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external view returns (uint256) {\n        return\n            interestRate.getSupplyRate(\n                getCashPrior(),\n                debtToken.totalSupply(),\n                totalReserves,\n                reserveFactorMantissa\n            );\n    }\n\n    /// @dev scales the input to from _underlyingDecimal to 18 decimal places\n    function normalize(uint256 _amount, uint8 _underlyingDecimal) internal pure returns (uint256) {\n        if (_underlyingDecimal >= 18) {\n            return _amount / 10**(_underlyingDecimal - 18);\n        } else {\n            return _amount * (10**(18 - _underlyingDecimal));\n        }\n    }\n\n    /// @dev scales the input to from 18 decinal to underlying decimal places\n    function denormalize(uint256 _amount, uint8 _underlyingDecimal)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_underlyingDecimal >= 18) {\n            return _amount * 10**(_underlyingDecimal - 18);\n        } else {\n            return _amount / (10**(18 - _underlyingDecimal));\n        }\n    }\n}"
    },
    "contracts/math/Exponential.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\n\ncontract Exponential {\n    uint256 constant expScale = 1e18;\n    // uint constant doubleScale = 1e36;\n    // uint constant halfExpScale = expScale/2;\n    uint256 constant mantissaOne = expScale;\n\n    struct Exp {\n        uint256 mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint256 num, uint256 denom) internal pure returns (Exp memory) {\n        uint256 scaledNumerator = num * expScale;\n        uint256 rational = scaledNumerator / denom;\n        return Exp({mantissa: rational});\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (Exp memory) {\n        uint256 scaledMantissa = a.mantissa * scalar;\n        return Exp({mantissa: scaledMantissa});\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n        Exp memory product = mulScalar(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (uint256) {\n        Exp memory product = mulScalar(a, scalar);\n        return truncate(product) + addend;\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint256 scalar) internal pure returns (Exp memory) {\n        uint256 descaledMantissa = a.mantissa / scalar;\n        return Exp({mantissa: descaledMantissa});\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        uint256 numerator = expScale * scalar;\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (uint256)\n    {\n        Exp memory fraction = divScalarByExp(scalar, divisor);\n        return truncate(fraction);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint256) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n}\n"
    },
    "contracts/rewards/RewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../util/Initializable.sol\";\nimport \"../interfaces/IBSLendingPair.sol\";\nimport \"../interfaces/IRewardDistributor.sol\";\nimport \"../interfaces/IRewardDistributorManager.sol\";\n\nabstract contract RewardDistributorStorageV1 is IRewardDistributor, Initializable {\n    /// @dev PoolInfo\n    struct PoolInfo {\n        IERC20 receiptTokenAddr;\n        uint256 lastUpdateTimestamp;\n        uint256 accRewardTokenPerShare;\n        uint128 allocPoint;\n    }\n\n    /// @dev UserInfo\n    struct UserInfo {\n        uint256 lastAccRewardTokenPerShare;\n        uint256 pendingReward; // pending user reward to be withdrawn\n        uint256 lastUpdateTimestamp; // last time user accumulated rewards\n    }\n\n    /// @notice reward distributor name\n    string public name;\n\n    /// @dev bool to check if rewarddistributor is activate\n    bool public activated;\n\n    /// @notice reward token to be distributed to users\n    IERC20 public rewardToken;\n\n    /// @notice poolInfo\n    PoolInfo[] public poolInfo;\n\n    /// @notice userInfo\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    /// @notice queue for receipt tokens awaiting activation\n    address[] public pendingRewardActivation;\n\n    /// @dev token -> pool id, use the `getTokenPoolID` function\n    /// to get a receipt token pool id\n    mapping(address => uint256) internal tokenPoolIDPair;\n\n    /// @dev totalAllocPoint\n    uint256 public totalAllocPoint;\n\n    /// @notice start timestamp for distribution to begin\n    uint256 public startTimestamp;\n\n    /// @notice end timestamp for distribution to end\n    uint256 public override endTimestamp;\n\n    /// @notice responsible for updating reward distribution\n    address public guardian;\n\n    /// @notice rewardAmountDistributePerSecond scaled in 1e18\n    uint256 public rewardAmountDistributePerSecond;\n}\n\ncontract RewardDistributor is RewardDistributorStorageV1 {\n    using SafeERC20 for IERC20;\n\n    /// @notice manager\n    IRewardDistributorManager public immutable rewardDistributorManager;\n\n    uint256 private constant SHARE_SCALE = 1e12;\n\n    /// @dev grace period for user to claim rewards after endTimestamp\n    uint256 private constant CLAIM_REWARD_GRACE_PERIOD = 30 days;\n\n    /// @dev period for users to withdraw rewards after endTimestamp before it can be\n    /// reclaimed by the guardian to prevent funds being locked in contract\n    uint256 private constant WITHDRAW_REWARD_GRACE_PERIOD = 90 days;\n\n    event Withdraw(\n        address indexed distributor,\n        address indexed user,\n        uint256 indexed poolId,\n        address _to,\n        uint256 amount\n    );\n\n    event AddDistribution(\n        address indexed lendingPair,\n        address indexed distributor,\n        DistributorConfigVars vars,\n        uint256 timestamp\n    );\n\n    event UpdateDistribution(uint256 indexed pid, uint256 newAllocPoint, uint256 timestamp);\n\n    event AccumulateReward(address indexed receiptToken, uint256 indexed pid, address user);\n\n    event WithdrawUnclaimedReward(address indexed distributor, uint256 amount, uint256 timestamp);\n\n    event ActivateReward(address indexed distributor, uint256 timestamp);\n\n    event UpdateEndTimestamp(address indexed distributor, uint256 newTimestamp, uint256 timestamp);\n\n    modifier onlyGuardian {\n        require(msg.sender == guardian, \"ONLY_GUARDIAN\");\n        _;\n    }\n\n    /// @notice create a distributor\n    /// @param _rewardDistributorManager the reward distributor manager address\n    constructor(address _rewardDistributorManager) {\n        require(_rewardDistributorManager != address(0), \"INVALID_MANAGER\");\n        rewardDistributorManager = IRewardDistributorManager(_rewardDistributorManager);\n    }\n\n    /// @dev accumulates reward for a depositor\n    /// @param _tokenAddr token to reward\n    /// @param _user user to accumulate reward for\n    function accumulateReward(address _tokenAddr, address _user) external override {\n        require(_tokenAddr != address(0), \"INVALID_ADDR\");\n        uint256 pid = getTokenPoolID(_tokenAddr);\n\n        updatePoolAndDistributeUserReward(pid, _user);\n        emit AccumulateReward(_tokenAddr, pid, _user);\n    }\n\n    /// @dev intialize\n    /// @param _rewardToken asset to distribute\n    /// @param _amountDistributePerSecond amount to distributer per second\n    /// @param _startTimestamp time to start distributing\n    /// @param _endTimestamp time to end distributing\n    /// @param _guardian distributor guardian\n    function initialize(\n        string calldata _name,\n        IERC20 _rewardToken,\n        uint256 _amountDistributePerSecond,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        address _guardian\n    ) external override initializer {\n        require(address(_rewardToken) != address(0), \"INVALID_TOKEN\");\n        require(_guardian != address(0), \"INVALID_GUARDIAN\");\n        require(_amountDistributePerSecond > 0, \"INVALID_DISTRIBUTE\");\n        require(_startTimestamp > 0, \"INVALID_TIMESTAMP_1\");\n        require(_endTimestamp > 0, \"INVALID_TIMESTAMP_2\");\n        require(_endTimestamp > _startTimestamp, \"INVALID_TIMESTAMP_3\");\n\n        name = _name;\n        rewardToken = _rewardToken;\n        rewardAmountDistributePerSecond = _amountDistributePerSecond;\n        startTimestamp = _startTimestamp;\n        endTimestamp = _endTimestamp;\n        guardian = _guardian;\n\n        emit Initialized(\n            _rewardToken,\n            _amountDistributePerSecond,\n            _startTimestamp,\n            _endTimestamp,\n            _guardian,\n            block.timestamp\n        );\n    }\n\n    struct DistributorConfigVars {\n        uint128 collateralTokenAllocPoint;\n        uint128 debtTokenAllocPoint;\n        uint128 borrowAssetTokenAllocPoint;\n    }\n\n    /// @dev Add a distribution param for a lending pair\n    /// @param _allocPoints specifies the allocation points\n    /// @param _lendingPair the lending pair being added\n    function add(DistributorConfigVars calldata _allocPoints, IBSLendingPair _lendingPair)\n        external\n        onlyGuardian\n    {\n        uint256 _startTimestamp = startTimestamp;\n\n        // guardian can not add more once distribution starts\n        require(block.timestamp < _startTimestamp, \"DISTRIBUTION_STARTED\");\n\n        if (_allocPoints.collateralTokenAllocPoint > 0) {\n            createPool(\n                _allocPoints.collateralTokenAllocPoint,\n                _lendingPair.wrappedCollateralAsset(),\n                _startTimestamp\n            );\n        }\n\n        if (_allocPoints.debtTokenAllocPoint > 0) {\n            createPool(_allocPoints.debtTokenAllocPoint, _lendingPair.debtToken(), _startTimestamp);\n        }\n\n        if (_allocPoints.borrowAssetTokenAllocPoint > 0) {\n            createPool(\n                _allocPoints.borrowAssetTokenAllocPoint,\n                _lendingPair.wrapperBorrowedAsset(),\n                _startTimestamp\n            );\n        }\n\n        emit AddDistribution(address(_lendingPair), address(this), _allocPoints, block.timestamp);\n    }\n\n    /// @notice activatePendingRewards Activate pending reward in the manger\n    function activatePendingRewards() external {\n        for (uint256 i = 0; i < pendingRewardActivation.length; i++) {\n            rewardDistributorManager.activateReward(pendingRewardActivation[i]);\n        }\n\n        // reset storage\n        delete pendingRewardActivation;\n\n        // set activated to true\n        if (!activated) activated = true;\n\n        emit ActivateReward(address(this), block.timestamp);\n    }\n\n    /// @notice set update allocation point for a pool\n    function set(\n        uint256 _pid,\n        uint128 _allocPoint,\n        bool _withUpdate\n    ) public onlyGuardian {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        totalAllocPoint = (totalAllocPoint - poolInfo[_pid].allocPoint) + _allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n\n        emit UpdateDistribution(_pid, _allocPoint, block.timestamp);\n    }\n\n    function getMultiplier(uint256 _from, uint256 _to) internal view returns (uint256) {\n        if (_to > endTimestamp) _to = endTimestamp;\n        return _to - _from;\n    }\n\n    function pendingRewardToken(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][_user];\n        uint256 accRewardTokenPerShare = pool.accRewardTokenPerShare;\n        uint256 totalSupply = pool.receiptTokenAddr.totalSupply();\n\n        if (block.timestamp > pool.lastUpdateTimestamp && totalSupply != 0) {\n            accRewardTokenPerShare = calculatePoolReward(pool, totalSupply);\n        }\n\n        uint256 amount = pool.receiptTokenAddr.balanceOf(_user);\n\n        return calculatePendingReward(amount, accRewardTokenPerShare, user);\n    }\n\n    /// @dev return accumulated reward share for the pool\n    function calculatePoolReward(PoolInfo memory pool, uint256 totalSupply)\n        internal\n        view\n        returns (uint256 accRewardTokenPerShare)\n    {\n        if (pool.lastUpdateTimestamp >= endTimestamp) {\n            return pool.accRewardTokenPerShare;\n        }\n\n        uint256 multiplier = getMultiplier(pool.lastUpdateTimestamp, block.timestamp);\n        uint256 tokenReward =\n            (multiplier * rewardAmountDistributePerSecond * pool.allocPoint) / totalAllocPoint;\n        accRewardTokenPerShare =\n            pool.accRewardTokenPerShare +\n            ((tokenReward * SHARE_SCALE) / totalSupply);\n    }\n\n    /// @notice Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /// @notice Update reward variables of the given pool to be up-to-date.\n    /// @param _pid pool id\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.timestamp <= pool.lastUpdateTimestamp) {\n            return;\n        }\n        uint256 totalSupply = pool.receiptTokenAddr.totalSupply();\n\n        if (totalSupply == 0) {\n            pool.lastUpdateTimestamp = block.timestamp;\n            return;\n        }\n\n        pool.accRewardTokenPerShare = calculatePoolReward(pool, totalSupply);\n        pool.lastUpdateTimestamp = block.timestamp > endTimestamp ? endTimestamp : block.timestamp;\n    }\n\n    /// @dev user to withdraw accumulated rewards from a pool\n    /// @param _pid pool id\n    /// @param _to address to transfer rewards to\n    function withdraw(uint256 _pid, address _to) external {\n        require(_to != address(0), \"INVALID_TO\");\n\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        updatePoolAndDistributeUserReward(_pid, msg.sender);\n\n        uint256 amountToWithdraw = user.pendingReward;\n        if (amountToWithdraw == 0) return;\n\n        // set pending reward to 0\n        user.pendingReward = 0;\n        safeTokenTransfer(_to, amountToWithdraw);\n\n        emit Withdraw(address(this), msg.sender, _pid, _to, amountToWithdraw);\n    }\n\n    /// @dev update the end timestamp\n    /// @param _newEndTimestamp new end timestamp\n    function updateEndTimestamp(uint256 _newEndTimestamp) external onlyGuardian {\n        require(\n            block.timestamp < endTimestamp && _newEndTimestamp > endTimestamp,\n            \"INVALID_TIMESTAMP\"\n        );\n        endTimestamp = _newEndTimestamp;\n\n        emit UpdateEndTimestamp(address(this), _newEndTimestamp, block.timestamp);\n    }\n\n    /// @dev withdraw unclaimed rewards\n    /// @param _to address to withdraw to\n    function withdrawUnclaimedRewards(address _to) external onlyGuardian {\n        require(\n            block.timestamp > endTimestamp + WITHDRAW_REWARD_GRACE_PERIOD,\n            \"REWARD_PERIOD_ACTIVE\"\n        );\n        uint256 amount = rewardToken.balanceOf(address(this));\n        rewardToken.safeTransfer(_to, amount);\n\n        emit WithdrawUnclaimedReward(address(this), amount, block.timestamp);\n    }\n\n    // Safe token transfer function, just in case if rounding error causes pool to not have enough tokens\n    function safeTokenTransfer(address _to, uint256 _amount) internal {\n        uint256 balance = rewardToken.balanceOf(address(this));\n        if (_amount > balance) {\n            rewardToken.safeTransfer(_to, balance);\n        } else {\n            rewardToken.safeTransfer(_to, _amount);\n        }\n    }\n\n    function getTokenPoolID(address _receiptTokenAddr) public view returns (uint256 poolId) {\n        poolId = tokenPoolIDPair[address(_receiptTokenAddr)] - 1;\n    }\n\n    function calculatePendingReward(\n        uint256 _amount,\n        uint256 _accRewardTokenPerShare,\n        UserInfo memory _userInfo\n    ) internal view returns (uint256 pendingReward) {\n        if (\n            _userInfo.lastUpdateTimestamp >= endTimestamp ||\n            block.timestamp > endTimestamp + CLAIM_REWARD_GRACE_PERIOD ||\n            _amount == 0\n        ) return 0;\n\n        uint256 rewardDebt = (_amount * _userInfo.lastAccRewardTokenPerShare) / SHARE_SCALE;\n        pendingReward = ((_amount * _accRewardTokenPerShare) / SHARE_SCALE) - rewardDebt;\n        pendingReward += _userInfo.pendingReward;\n    }\n\n    /// @dev update pool and accrue rewards for user\n    /// @param _pid pool id\n    /// @param _user user to update rewards for\n    function updatePoolAndDistributeUserReward(uint256 _pid, address _user) internal {\n        if (activated == false || block.timestamp < startTimestamp) return;\n\n        // update the pool\n        updatePool(_pid);\n\n        PoolInfo memory pool = poolInfo[_pid];\n\n        if (_user != address(0)) {\n            UserInfo storage user = userInfo[_pid][_user];\n            uint256 amount = pool.receiptTokenAddr.balanceOf(_user);\n            user.pendingReward = calculatePendingReward(amount, pool.accRewardTokenPerShare, user);\n            user.lastAccRewardTokenPerShare = pool.accRewardTokenPerShare;\n            user.lastUpdateTimestamp = block.timestamp;\n        }\n    }\n\n    function createPool(\n        uint128 _allocPoint,\n        IERC20 _receiptTokenAddr,\n        uint256 _lastUpdateTimestamp\n    ) internal {\n        require(address(_receiptTokenAddr) != address(0), \"invalid_addr\");\n        require(tokenPoolIDPair[address(_receiptTokenAddr)] == 0, \"token_exists\");\n\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n\n        poolInfo.push(\n            PoolInfo({\n                receiptTokenAddr: _receiptTokenAddr,\n                allocPoint: _allocPoint,\n                lastUpdateTimestamp: _lastUpdateTimestamp,\n                accRewardTokenPerShare: 0\n            })\n        );\n\n        tokenPoolIDPair[address(_receiptTokenAddr)] = poolInfo.length;\n        pendingRewardActivation.push(address(_receiptTokenAddr));\n    }\n}\n"
    },
    "contracts/test/MockRewardDistributorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"../interfaces/IRewardDistributorManager.sol\";\nimport \"../upgradability/UUPSProxiable.sol\";\n\ncontract MockRewardDistributorManager is UUPSProxiable, IRewardDistributorManager {\n    function activateReward(address _tokenAddr) external pure override {\n        _tokenAddr;\n        return;\n    }\n\n    function removeReward(address _tokenAddr, IRewardDistributor _distributor)\n        external\n        pure\n        override\n    {\n        _tokenAddr;\n        _distributor;\n        return;\n    }\n\n    function accumulateRewards(address _from, address _to) external pure override {\n        _from;\n        _to;\n        return;\n    }\n\n    function proxiableUUID() public pure override returns (bytes32) {\n        return keccak256(\"org.warp.contracts.warprewards.implementation\");\n    }\n\n    function updateCode(address newAddress) external override {\n        _updateCodeAddress(newAddress);\n    }\n}\n"
    },
    "contracts/upgradability/UUPSProxiable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport {UUPSUtils} from \"./UUPSUtils.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev UUPS (Universal Upgradeable Proxy Standard) Proxiable contract.\n */\nabstract contract UUPSProxiable is Initializable {\n    /**\n     * @dev Get current implementation code address.\n     */\n    function getCodeAddress() public view returns (address codeAddress) {\n        return UUPSUtils.implementation();\n    }\n\n    function updateCode(address newAddress) external virtual;\n\n    /**\n     * @dev Proxiable UUID marker function.\n     *      This would help to avoid wrong logic contract to be used for upgrading.\n     */\n    function proxiableUUID() public view virtual returns (bytes32);\n\n    /**\n     * @dev Update code address function.\n     *      It is internal, so the derived contract could setup its own permission logic.\n     */\n    function _updateCodeAddress(address newAddress) internal {\n        require(UUPSUtils.implementation() != address(0), \"UUPSProxiable: not upgradable\");\n        require(\n            proxiableUUID() == UUPSProxiable(newAddress).proxiableUUID(),\n            \"UUPSProxiable: not compatible logic\"\n        );\n        UUPSUtils.setImplementation(newAddress);\n        emit CodeUpdated(proxiableUUID(), newAddress);\n    }\n\n    event CodeUpdated(bytes32 uuid, address codeAddress);\n}\n"
    },
    "contracts/upgradability/UUPSUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\n/**\n * @title UUPS (Universal Upgradeable Proxy Standard) Shared Library\n */\nlibrary UUPSUtils {\n    /**\n     * @dev Implementation slot constant.\n     * Using https://eips.ethereum.org/EIPS/eip-1967 standard\n     * Storage slot 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n     * (obtained as bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)).\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Get implementation address.\n    function implementation() internal view returns (address impl) {\n        assembly {\n            // solium-disable-line\n            impl := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /// @dev Set new implementation address.\n    function setImplementation(address codeAddress) internal {\n        assembly {\n            // solium-disable-line\n            sstore(_IMPLEMENTATION_SLOT, codeAddress)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/VaultBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./util/ReentrancyGuard.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { UUPSProxiable } from \"./upgradability/UUPSProxiable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./interfaces/IBSVault.sol\";\n\nabstract contract VaultStorageV1 is ReentrancyGuard, UUPSProxiable, Pausable, IBSVault {\n    struct TotalBase {\n        uint256 totalUnderlyingDeposit; // total underlying asset deposit\n        uint256 totalSharesMinted; // total vault shares minted\n    }\n\n    /// @notice the flashloan rate to charge for flash loans\n    uint256 public flashLoanRate;\n\n    /// @notice the address that access to perform `admin` functions\n    address public owner;\n\n    /// @dev the address that access to perform `admin` functions\n    address public newOwner;\n\n    /// @dev cached domain separator\n    bytes32 internal _CACHED_DOMAIN_SEPARATOR;\n\n    /// @notice mapping of token asset to user address and balance\n    mapping(IERC20 => mapping(address => uint256)) public override balanceOf;\n\n    /// @notice mapping of user to contract to approval status\n    mapping(address => mapping(address => bool)) public userApprovedContracts;\n\n    /// @notice mapping of user to approval nonce\n    mapping(address => uint256) public userApprovalNonce;\n\n    /// @notice mapping to contract to whitelist status\n    mapping(address => bool) public allowedContracts;\n\n    /// @notice mapping of asset to total deposit and shares minted\n    mapping(IERC20 => TotalBase) public totals;\n\n}\n\nabstract contract VaultBase is VaultStorageV1  {\n    /// @notice vault name\n    string public constant name = \"WarpVault v1\";\n\n    /// @notice vault version\n    string public constant version = \"1\";\n\n    /// @dev vault approval message digest\n    bytes32 internal constant _VAULT_APPROVAL_SIGNATURE_TYPE_HASH =\n        keccak256(\n            \"VaultAccessApproval(bytes32 warning,address user,address contract,bool approved,uint256 nonce)\"\n        );\n\n    /// @dev EIP712 type hash\n    bytes32 internal constant _EIP712_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n    \n    /// @dev ERC3156 constant for flashloan callback success\n    bytes32 internal constant FLASHLOAN_CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    \n    /// @notice max flashlaon rate 10%\n    uint256 public constant MAX_FLASHLOAN_RATE = 1e17;\n\n    /// @dev minimum vault share balance\n    uint256 internal constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off\n\n    bytes32 internal immutable _HASHED_NAME;\n    bytes32 internal immutable _HASHED_VERSION;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    constructor() {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _CACHED_CHAIN_ID = _getChainId();\n    }\n\n    function _buildDomainSeparator(\n        bytes32 _typeHash,\n        bytes32 _name,\n        bytes32 _version\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encode(_typeHash, _name, _version, _getChainId(), address(this)));\n    }\n\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_EIP712_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // solhint-disable-next-line\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/util/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __init_ReentrancyGuard () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"./upgradability/UUPSProxy.sol\";\nimport \"./interfaces/IBSVault.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title VaultFactory\n/// @author @samparsky\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract VaultFactory {\n    /// @dev vault logic address\n    address public vaultLogic;\n    /// @dev owner that can update vault logic address\n    address public immutable owner;\n\n    event NewVault(address vault, uint256 created);\n    event VaultUpdated(address vault, uint256 created);\n\n    /// @notice modifier to allow only the owner to call a function\n    modifier onlyOwner {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    constructor(address _owner, address _vaultLogic) {\n        require(_vaultLogic != address(0), \"INVALID_VAULT\");\n        require(_owner != address(0), \"INVALID_OWNER\");\n\n        owner = _owner;\n        vaultLogic = _vaultLogic;\n    }\n\n    /// @notice update the vault logic address\n    /// @param _newVault the address of the new vault logic\n    function updateVaultLogic(address _newVault) external onlyOwner {\n        require(_newVault != address(0), \"INVALID_VAULT\");\n\n        vaultLogic = _newVault;\n        emit VaultUpdated(_newVault, block.timestamp);\n    }\n\n    /// @notice create an upgradable vault\n    /// @param _flashLoanRate flash loan rate to charge\n    /// @param _vaultOwner address allowed to perform vault `admin` functions\n    function createUpgradableVault(uint256 _flashLoanRate, address _vaultOwner)\n        external\n        onlyOwner\n        returns (address proxy)\n    {\n        UUPSProxy uupsProxy = new UUPSProxy();\n        uupsProxy.initializeProxy(vaultLogic);\n\n        proxy = address(uupsProxy);\n        \n        // initiailize vault & validates the input properties\n        IBSVault(proxy).initialize(_flashLoanRate, _vaultOwner);\n\n        emit NewVault(proxy, block.timestamp);\n    }\n}\n"
    },
    "contracts/upgradability/UUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport {UUPSUtils} from \"./UUPSUtils.sol\";\nimport {Proxy} from \"@openzeppelin/contracts/proxy/Proxy.sol\";\n\n/**\n * @dev UUPS (Universal Upgradeable Proxy Standard) Proxy\n *\n * NOTE:\n * - Compliant with [Universal Upgradeable Proxy Standard](https://eips.ethereum.org/EIPS/eip-1822)\n * - Compiiant with [Standard Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967)\n * - Implements delegation of calls to other contracts, with proper forwarding of\n *   return values and bubbling of failures.\n * - It defines a fallback function that delegates all calls to the implementation.\n */\ncontract UUPSProxy is Proxy {\n    /**\n     * @dev Proxy initialization function.\n     *      This should only be called once and it is permission-less.\n     * @param initialAddress Initial logic contract code address to be used.\n     */\n    function initializeProxy(address initialAddress) external {\n        require(initialAddress != address(0), \"UUPSProxy: zero address\");\n        require(UUPSUtils.implementation() == address(0), \"UUPSProxy: already initialized\");\n        UUPSUtils.setImplementation(initialAddress);\n    }\n\n    /// @dev Proxy._implementation implementation\n    function _implementation() internal view virtual override returns (address) {\n        return UUPSUtils.implementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "contracts/test/MockVaultUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"../interfaces/IBSVault.sol\";\n\ncontract MockVaultUser {\n    function execute(IBSVault _vault, address _approve) external {\n        _vault.approveContract(address(this), _approve, true, 0, 0, 0);\n    }\n\n    function attack(IBSVault _vault) external {\n        _vault.approveContract(address(this), address(this), true, 0, 0, 0);\n    }\n} "
    },
    "contracts/test/MockFlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IERC3156FlashBorrower.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\n\n/// Dummy contract to test FlashLoan\n\ncontract MockFlashBorrower is IERC3156FlashBorrower {\n    function onFlashLoan(\n        address _initiator,\n        address _token,\n        uint256 _amount,\n        uint256 _fees,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(_initiator != address(0), \"sender is 0\");\n        require(data.length >= 0, \"data < 0\");\n        bool shouldAddFees = abi.decode(data, (bool));\n\n        if (shouldAddFees) {\n            IERC20(_token).approve(msg.sender, _amount + _fees);\n        } else {\n            IERC20(_token).approve(msg.sender, _amount);\n        }\n        // IERC20(_token).transfer(msg.sender, _amount + _fees);\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function borrow(\n        address _lender,\n        address _token,\n        uint256 _amount\n    ) external {\n        IERC3156FlashLender(_lender).flashLoan(\n            IERC3156FlashBorrower(address(this)),\n            _token,\n            _amount,\n            \"0x\"\n        );\n    }\n}\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./VaultBase.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title Vault\n/// @author @samparsky\n/// @notice Vault contract stores assets deposited into the Lending pairs.\n/// It enables deposit, withdrawal, flashloans and transfer of tokens.\n/// It represents the deposited token amount in form of shares\n/// This contract implements the EIP3156 IERC3156FlashBorrower for flashloans.\n/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.\n/// \n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract Vault is VaultBase {\n    using SafeERC20 for IERC20;\n\n    /// @notice modifier to allow only blacksmith team to call a function\n    modifier onlyOwner {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    modifier allowed(address _from) {\n        require(\n            msg.sender == _from || userApprovedContracts[_from][msg.sender] == true,\n            \"ONLY_ALLOWED\"\n        );\n        _;\n    }\n\n    /// @dev setup a vault\n    constructor() VaultBase() {}\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // UUPSProxiable\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function initialize(uint256 _flashLoanRate, address _owner) external override initializer {\n        require(_owner != address(0), \"INVALID_OWNER\");\n        require(flashLoanRate < MAX_FLASHLOAN_RATE, \"INVALID_RATE\");\n\n        __init_ReentrancyGuard();\n        \n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n            _EIP712_TYPE_HASH,\n            _HASHED_NAME,\n            _HASHED_VERSION\n        );\n        \n        flashLoanRate = _flashLoanRate;\n        owner = _owner;\n    }\n\n    function proxiableUUID() public pure override returns (bytes32) {\n        return keccak256(\"org.warp.contracts.warpvault.implementation\");\n    }\n\n    function updateCode(address newAddress) external override onlyOwner {\n        _updateCodeAddress(newAddress);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Vault Actions\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Enables or disables a contract for approval without signed message.\n    function allowContract(address _contract, bool _status) external onlyOwner {\n        // Checks\n        require(_contract != address(0), \"invalid_address\");\n\n        // Effects\n        allowedContracts[_contract] = _status;\n        emit AllowContract(_contract, _status);\n    }\n    \n    /// @notice approve a contract to enable the contract to withdraw\n    function approveContract(\n        address _user,\n        address _contract,\n        bool _status,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(_contract != address(0), \"INVALID_CONTRACT\");\n        require(_user != address(0), \"INVALID_USER\");\n\n        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\n            // ensure that user match\n            require(_user == msg.sender, \"NOT_SENDER\");\n            // ensure that it's a contract\n            require(msg.sender != tx.origin, \"ONLY_CONTRACT\");\n            // ensure that _user != _contract\n            require(_user != _contract, \"INVALID_APPROVE\");\n            // ensure that _contract is allowed\n            require(allowedContracts[_contract], \"NOT_WHITELISTED\");\n        } else {\n            bytes32 digest =\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        _domainSeparatorV4(),\n                        keccak256(\n                            abi.encode(\n                                _VAULT_APPROVAL_SIGNATURE_TYPE_HASH,\n                                _status\n                                    // solhint-disable-next-line\n                                    ? keccak256(\"Grant full access to funds in Warp Vault? Read more here https://warp.finance/permission\")\n                                    : keccak256(\n                                        \"Revoke access to Warp Vault? Read more here https://warp.finance/revoke\"\n                                    ),\n                                _user,\n                                _contract,\n                                _status,\n                                userApprovalNonce[_user]++\n                            )\n                        )\n                    )\n                );\n\n                address recoveredAddress = ecrecover(digest, v, r, s);\n                require(recoveredAddress == _user, \"INVALID_SIGNATURE\");\n        }\n\n        userApprovedContracts[_user][_contract] = _status;\n\n        emit Approval(_user, _contract, _status);\n    }\n\n    /// @notice pause vault actions\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice unpause vault actions\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice Deposit an amount of `token`\n    /// @param _token The ERC-20 token to deposit.\n    /// @param _from which account to pull the tokens.\n    /// @param _to which account to push the tokens.\n    /// @param _amount Token amount in native representation to deposit.\n    /// @return shareOut The deposit amount in vault shares\n    function deposit(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override whenNotPaused allowed(_from) nonReentrant returns (uint256 shareOut) {\n        // Checks\n        require(_to != address(0), \"INVALID_TO_ADDRESS\");\n\n        // calculate shares\n        shareOut = toShare(_token, _amount, false);\n\n        // transfer appropriate amount of underlying from _from to vault\n        _token.safeTransferFrom(_from, address(this), _amount);\n\n        balanceOf[_token][_to] = balanceOf[_token][_to] + shareOut;\n        \n        TotalBase storage total = totals[_token];\n        total.totalUnderlyingDeposit += _amount;\n        total.totalSharesMinted += shareOut;\n\n        emit Deposit(_token, _from, _to, _amount, shareOut);\n    }\n\n    /// @notice Withdraw the underlying share of `token` from a user account.\n    /// @param _token The ERC-20 token to withdraw.\n    /// @param _from which user to pull the tokens.\n    /// @param _to which user to push the tokens.\n    /// @param _shares of shares to withdraw\n    /// @return amountOut The amount of underlying transferred\n    function withdraw(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _shares\n    ) external override whenNotPaused allowed(_from) nonReentrant returns (uint256 amountOut) {\n        // Checks\n        require(_to != address(0), \"INVALID_TO_ADDRESS\");\n\n        amountOut = toUnderlying(_token, _shares);\n        balanceOf[_token][_from] = balanceOf[_token][_from] - _shares;\n\n        TotalBase storage total = totals[_token];\n\n        total.totalUnderlyingDeposit -= amountOut;\n        total.totalSharesMinted -= _shares;\n\n        // prevents the ratio from being reset\n        require(\n            total.totalSharesMinted >= MINIMUM_SHARE_BALANCE\n            || \n            total.totalSharesMinted == 0, \"INVALID_RATIO\"\n        );\n\n        _token.safeTransfer(_to, amountOut);\n\n        emit Withdraw(_token, _from, _to, _shares, amountOut);\n    }\n\n    /// @notice Transfer share of `token` to another account\n    /// @param _token The ERC-20 token to transfer.\n    /// @param _from which user to pull the tokens.\n    /// @param _to which user to push the tokens.\n    /// @param _shares of shares to transfer\n    function transfer(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _shares\n    ) external override whenNotPaused allowed(_from) {\n        _transfer(_token, _from, _to, _shares);\n    }\n\n    /// @notice accept transfer of control\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"invalid owner\");\n        owner = newOwner;\n        newOwner = address(0);\n        emit OwnershipAccepted(newOwner, block.timestamp);\n    }\n\n    /// @notice Transfer control from current owner address to another\n    /// @param _newOwner The new team\n    function transferToNewOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"INVALID_NEW_OWNER\");\n        newOwner = _newOwner;\n        emit TransferControl(_newOwner, block.timestamp);\n    }\n\n    function _transfer(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _shares\n    ) internal {\n        require(_to != address(0), \"INVALID_TO_ADDRESS\");\n        // Effects\n        balanceOf[_token][_from] = balanceOf[_token][_from] - _shares;\n        balanceOf[_token][_to] = balanceOf[_token][_to] + _shares;\n        emit Transfer(_token, _from, _to, _shares);\n    }\n\n    /// @notice The amount of currency available to be lent.\n    /// @param _token The loan currency.\n    /// @return The amount of `token` that can be borrowed.\n    function maxFlashLoan(address _token) external view override returns (uint256) {\n        return totals[IERC20(_token)].totalUnderlyingDeposit;\n    }\n\n    /// @notice The fee to be charged for a given loan.\n    /// @param // _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.\n    function flashFee(address, uint256 _amount) public view override returns (uint256) {\n        return (_amount * flashLoanRate) / 1e18;\n    }\n\n    /// @notice Initiate a flash loan.\n    /// @param _receiver The receiver of the tokens in the loan, and the receiver of the callback.\n    /// @param _token The loan currency.\n    /// @param _amount The amount of tokens lent.\n    /// @param _data Arbitrary data structure, intended to contain user-defined parameters.\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override nonReentrant returns (bool) {\n        require(totals[IERC20(_token)].totalUnderlyingDeposit >= _amount, \"Not enough balance\");\n\n        IERC20 token = IERC20(_token);\n\n        uint256 tokenBalBefore = token.balanceOf(address(this));\n        token.safeTransfer(address(_receiver), _amount);\n\n        uint256 fee = flashFee(_token, _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                FLASHLOAN_CALLBACK_SUCCESS,\n            \"IERC3156: Callback failed\"\n        );\n\n        // receive loans and fees\n        token.safeTransferFrom(address(_receiver), address(this), _amount + fee);\n\n        uint256 receivedFees = token.balanceOf(address(this)) - tokenBalBefore;\n        require(receivedFees >= fee, \"not enough fees\");\n        \n        totals[IERC20(_token)].totalUnderlyingDeposit += fee;\n\n        emit FlashLoan(msg.sender, token, _amount, fee, address(_receiver));\n\n        return true;\n    }\n\n    /// @dev Update the flashloan rate charged, only owner can call\n    /// @param _newRate The ERC-20 token.\n    function updateFlashloanRate(uint256 _newRate) external onlyOwner {\n        require(_newRate < MAX_FLASHLOAN_RATE, \"invalid rate\");\n        flashLoanRate = _newRate;\n        emit UpdateFlashLoanRate(_newRate);\n    }\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param _token The ERC-20 token.\n    /// @param _amount The `token` amount.\n    /// @param _ceil If to ceil the amount or not\n    /// @return share The token amount represented in shares.\n    function toShare(\n        IERC20 _token,\n        uint256 _amount,\n        bool _ceil\n    ) public view override returns (uint256 share) {\n        TotalBase storage total = totals[_token];\n\n        uint256 currentTotal = total.totalSharesMinted;\n        if (currentTotal > 0) {\n            uint256 currentUnderlyingBalance = total.totalUnderlyingDeposit;\n            share = (_amount * currentTotal) / currentUnderlyingBalance;\n\n            if (_ceil && ((share * currentUnderlyingBalance) / currentTotal) < _amount) {\n                share = share + 1;\n            }\n        } else {\n            share = _amount;\n        }\n    }\n\n    /// @notice Helper function represent shares back into the `token` amount.\n    /// @param _token The ERC-20 token.\n    /// @param _share The amount of shares.\n    /// @return amount The share amount back into native representation.\n    function toUnderlying(IERC20 _token, uint256 _share)\n        public\n        view\n        override\n        returns (uint256 amount)\n    {\n        TotalBase storage total = totals[_token];\n        amount = (_share * total.totalUnderlyingDeposit) / total.totalSharesMinted;\n    }\n\n    /// @notice rescueFunds Enables us to rescue funds that are not tracked\n    /// @param _token ERC20 token to rescue funds from\n    function rescueFunds(IERC20 _token) external nonReentrant onlyOwner {\n        uint256 currentBalance = _token.balanceOf(address(this));\n        uint256 amount = currentBalance - totals[_token].totalUnderlyingDeposit;\n        _token.safeTransfer(owner, amount);\n\n        emit RescueFunds(_token, amount);\n    }\n}\n"
    },
    "contracts/test/VaultStorageLayoutTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"../Vault.sol\";\nimport \"hardhat/console.sol\";\n\ncontract VaultStorageLayoutTester is Vault {\n    constructor() Vault() {}\n\n    function validateStorageLayout() external pure {\n        uint256 slot;\n        uint256 offset;\n\n        assembly {\n            slot := flashLoanRate.slot\n            offset := flashLoanRate.offset\n        }\n        require(slot == 2 && offset == 0, \"flashloan rate has changed location\");\n\n        assembly {\n            slot := owner.slot\n            offset := owner.offset\n        }\n        require(slot == 3 && offset == 0, \"owner has changed location\");\n\n        assembly {\n            slot := newOwner.slot\n            offset := newOwner.offset\n        }\n        require(slot == 4 && offset == 0, \"owner has changed location\");\n\n        assembly {\n            slot := _CACHED_DOMAIN_SEPARATOR.slot\n            offset := _CACHED_DOMAIN_SEPARATOR.offset\n        }\n        require(slot == 5 && offset == 0, \"_CACHED_DOMAIN_SEPARATOR rate has changed location\");\n\n        assembly {\n            slot := balanceOf.slot\n            offset := balanceOf.offset\n        }\n        require(slot == 6 && offset == 0, \"balanceOf rate has changed location\");\n\n        assembly {\n            slot := userApprovedContracts.slot\n            offset := userApprovedContracts.offset\n        }\n        require(slot == 7 && offset == 0, \"userApprovedContracts rate has changed location\");\n\n        assembly {\n            slot := userApprovalNonce.slot\n            offset := userApprovalNonce.offset\n        }\n\n        require(slot == 8 && offset == 0, \"userApprovedContracts rate has changed location\");\n\n        assembly {\n            slot := allowedContracts.slot\n            offset := allowedContracts.offset\n        }\n        require(slot == 9 && offset == 0, \"allowedContracts has changed location\");\n\n        assembly {\n            slot := totals.slot\n            offset := totals.offset\n        }\n        require(slot == 10 && offset == 0, \"totals has changed location\");\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/helper/FeeWithdrawal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {UUPSProxiable} from \"../upgradability/UUPSProxiable.sol\";\nimport \"../interfaces/IBSLendingPair.sol\";\n\ncontract FeeWithdrawal is UUPSProxiable {\n    using SafeERC20 for IERC20;\n\n    event LogUpdateAdmin(address newAdmin, uint256 timestamp);\n    event LogRescueFunds(address token, uint256 amount, uint256 timestamp);\n    event LogTransferToReceiver(address receiver, uint256 amount, uint256 timestamp);\n    event LogWithdrawFees(uint256 totalWithdrawnFees, uint256 timestamp);\n    event LogWithSwap(uint256 totalWarpReceived, uint256 timestamp);\n\n    uint256 public constant VERSION = 0x1;\n\n    /// @notice The address to transfer the swapped WARP to\n    address public immutable receiver;\n\n    /// @notice vault address\n    IBSVault public immutable vault;\n\n    /// @notice the token's address that is swapped against any other fee token\n    address public immutable warpToken;\n\n    /// @notice WETH address\n    address public immutable WETH;\n\n    /// @notice The admin\n    address public admin;\n\n    /// @notice IUniswapRouter used to swap erc20 fee token into warpToken\n    IUniswapV2Router02 public uniswapRouter;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    modifier onlyEOA() {\n        // Try to make flash-loan exploit harder to do by only allowing externally-owned addresses.\n        require(msg.sender == tx.origin, \"MUST_BE_EOA\");\n        _;\n    }\n\n    /**\n     * @notice Create a new FeeWithdrawal contract\n     * @param _vault vault address\n     * @param _receiver address of the contract to transfer Warp to\n     * @param _warpToken address of warp token\n     * @param _wethAddress WETH address\n     */\n    constructor(\n        IBSVault _vault,\n        address _receiver,\n        address _warpToken,\n        address _wethAddress\n    ) {\n        require(address(_vault) != address(0), \"INVALID_VAULT\");\n        require(_receiver != address(0), \"INVALID_RECEIVER\");\n\n        require(_warpToken != address(0), \"FeeWithdrawal: invalid token address\");\n\n        require(_wethAddress != address(0), \"FeeWithdrawal: invalid weth address\");\n\n        warpToken = _warpToken;\n        WETH = _wethAddress;\n        vault = _vault;\n        receiver = _receiver;\n    }\n\n    /// @dev to avoid gas costs we are gonna send the underlying pair's asset as param & compute the amount off-chain\n    /// @param _lendingPairs lending pair addresses\n    function withdrawFees(IBSLendingPair[] calldata _lendingPairs) external onlyEOA {\n        require(_lendingPairs.length > 0, \"lendingPairs.length\");\n\n        uint256 totalWithdrawnFees = 0;\n\n        for (uint256 i = 0; i < _lendingPairs.length; i++) {\n            IBSLendingPair pair = _lendingPairs[i];\n\n            IERC20 asset = pair.asset();\n            uint256 amountToWithdraw = pair.totalReserves();\n\n            // withdraw to vault\n            pair.withdrawFees(amountToWithdraw);\n\n            // withdraw underlying\n            vault.withdraw(asset, address(this), address(this), amountToWithdraw);\n\n            totalWithdrawnFees += amountToWithdraw;\n        }\n\n        emit LogWithdrawFees(totalWithdrawnFees, block.timestamp);\n    }\n\n    /// @dev swap Fees with warpToken\n    /// @param _assets assets to be swaped\n    /// @param amountOuts Minimum expected amountOut of the lending pair reserve swap\n    function swapFees(IERC20[] calldata _assets, uint256[] calldata amountOuts) external onlyAdmin {\n        require(_assets.length > 0, \"assets.length\");\n\n        uint256 totalWarpReceived = 0;\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            IERC20 asset = _assets[i];\n\n            uint256 amountToTrade = asset.balanceOf(address(this));\n\n            if (address(asset) != warpToken) {\n                totalWarpReceived += _convertToWarp(address(asset), amountToTrade, amountOuts[i]);\n            } else {\n                totalWarpReceived += amountToTrade;\n            }\n        }\n\n        emit LogWithSwap(totalWarpReceived, block.timestamp);\n    }\n\n    function transferToReceiver() external {\n        uint256 amount = IERC20(warpToken).balanceOf(address(this));\n        IERC20(warpToken).transfer(receiver, amount);\n\n        emit LogTransferToReceiver(receiver, amount, block.timestamp);\n    }\n\n    function updateAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"INVALID_ADMIN\");\n        admin = _newAdmin;\n        emit LogUpdateAdmin(_newAdmin, block.timestamp);\n    }\n\n    function rescueFunds(address _token) external onlyAdmin {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(admin, balance);\n        emit LogRescueFunds(_token, balance, block.timestamp);\n    }\n\n    function getPath(address from) internal view returns (address[] memory path) {\n        if (from == WETH) {\n            path = new address[](2);\n            path[0] = WETH;\n            path[1] = warpToken;\n        } else {\n            path = new address[](3);\n            path[0] = from;\n            path[1] = WETH;\n            path[2] = warpToken;\n        }\n    }\n\n    function _convertToWarp(\n        address from,\n        uint256 amount,\n        uint256 amountOut\n    ) private returns (uint256) {\n        address[] memory path = getPath(from);\n\n        IERC20(from).safeIncreaseAllowance(address(uniswapRouter), amount);\n\n        uint256[] memory amounts =\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, path, address(this), 10**64);\n\n        return amounts[amounts.length - 1];\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // UUPSProxiable\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function initialize(address _admin, address _uniswapV2Router) external initializer {\n        require(_admin != address(0), \"INVALID_ADMIN\");\n        admin = _admin;\n\n        require(_uniswapV2Router != address(0), \"FeeWithdrawal: invalid router address\");\n        uniswapRouter = IUniswapV2Router02(_uniswapV2Router);\n    }\n\n    function proxiableUUID() public pure override returns (bytes32) {\n        return keccak256(\"org.warp.contracts.warphelper.feewithdrawal\");\n    }\n\n    function updateCode(address newAddress) external override onlyAdmin {\n        _updateCodeAddress(newAddress);\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/rewards/RewardDistributorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IRewardDistributor.sol\";\nimport \"../interfaces/IBSLendingPair.sol\";\nimport \"../upgradability/UUPSProxiable.sol\";\nimport \"../interfaces/IRewardDistributorManager.sol\";\n\nabstract contract RewardDistirbutorManagerStorageV1 is UUPSProxiable, IRewardDistributorManager {\n    /// @dev admin\n    address public owner;\n\n    /// @dev newAdmin\n    address internal newOwner;\n\n    /// @dev approvedistributions\n    mapping(IRewardDistributor => bool) public approvedDistributors;\n\n    /// @dev receipt token address => distributor\n    mapping(address => IRewardDistributor[]) public tokenRewardToDistributors;\n}\n\ncontract RewardDistributorManager is RewardDistirbutorManagerStorageV1 {\n    modifier onlyOwner {\n        require(owner == msg.sender, \"ONLY_OWNER\");\n        _;\n    }\n\n    /// @notice initialize\n    /// @param _owner owner to perform owner functions\n    function initialize(address _owner) external initializer {\n        require(_owner != address(0), \"INVALID_OWNER\");\n\n        owner = _owner;\n\n        emit Initialized(_owner, block.timestamp);\n    }\n\n    /// @dev Accumulates rewards for users\n    /// @param _from user address\n    /// @param _to user address\n    function accumulateRewards(address _from, address _to) external override {\n        IRewardDistributor[] memory distributors = tokenRewardToDistributors[msg.sender];\n        uint256 size = distributors.length;\n\n        if (size == 0) return;\n\n        /// We need to manage the size of the rewards to prevent\n        /// astronomical increase in gas cost\n        for (uint256 i = 0; i < size; i++) {\n            if (_from != address(0)) distributors[i].accumulateReward(msg.sender, _from);\n            if (_to != address(0)) distributors[i].accumulateReward(msg.sender, _to);\n        }\n    }\n\n    /// @dev approves a distributor contract for a token\n    /// @param _distributor The distributor contract address\n    /// @param _approve the status of the distributor contract\n    function setDistributorStatus(IRewardDistributor _distributor, bool _approve)\n        external\n        onlyOwner\n    {\n        approvedDistributors[_distributor] = _approve;\n        emit ApprovedDistributor(_distributor, block.timestamp);\n    }\n\n    /// @dev Enables a distributor contract to activate reward for a token\n    /// @param _tokenAddr the token the distributor contract is adding a reward for\n    function activateReward(address _tokenAddr) external override {\n        require(\n            approvedDistributors[IRewardDistributor(msg.sender)] == true,\n            \"ONLY_APPROVED_DISTRIBUTOR\"\n        );\n\n        IRewardDistributor[] storage distributors = tokenRewardToDistributors[_tokenAddr];\n\n        require(\n            findRewardDistributor(distributors, IRewardDistributor(msg.sender)) == -1,\n            \"DISTRIBUTOR_EXISTS\"\n        );\n\n        distributors.push(IRewardDistributor(msg.sender));\n\n        emit AddReward(_tokenAddr, IRewardDistributor(msg.sender), block.timestamp);\n    }\n\n    /// @dev Remove  a reward distributor\n    /// @param _tokenAddr address of the receipt token\n    /// @param _distributor distributor contract\n    function removeReward(address _tokenAddr, IRewardDistributor _distributor)\n        external\n        override\n        onlyOwner\n    {\n        IRewardDistributor[] storage distributors = tokenRewardToDistributors[_tokenAddr];\n        uint256 size = distributors.length;\n\n        int256 rewardIndex = findRewardDistributor(distributors, _distributor);\n        if (rewardIndex == -1) return;\n\n        distributors[uint256(rewardIndex)] = distributors[size - 1];\n        // used pop instead of delete because pop reduces array length\n        distributors.pop();\n\n        emit RemoveReward(_tokenAddr, _distributor, block.timestamp);\n    }\n\n    function findRewardDistributor(\n        IRewardDistributor[] memory distributors,\n        IRewardDistributor _distributor\n    ) internal pure returns (int256 index) {\n        index = -1;\n        uint256 size = distributors.length;\n        for (uint256 i = 0; i < size; i++) {\n            if (address(distributors[i]) == address(_distributor)) {\n                index = int256(i);\n                break;\n            }\n        }\n    }\n\n    function commitOwnerTransfer(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"INVALID_NEW_OWNER\");\n        newOwner = _newOwner;\n        emit TransferControl(_newOwner, block.timestamp);\n    }\n\n    function acceptOwnerTransfer() external {\n        require(msg.sender == newOwner, \"invalid owner\");\n        owner = newOwner;\n        newOwner = address(0);\n        emit OwnershipAccepted(newOwner, block.timestamp);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // UUPSProxiable\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    function proxiableUUID() public pure override returns (bytes32) {\n        return keccak256(\"org.warp.contracts.warprewards.implementation\");\n    }\n\n    function updateCode(address newAddress) external override onlyOwner {\n        _updateCodeAddress(newAddress);\n    }\n}\n"
    },
    "contracts/rewards/RewardDistributorFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IRewardDistributor.sol\";\n\ncontract RewardDistributorFactory {\n    using Clones for address;\n\n    event NewImpl(address pairLogic, uint256 timestamp);\n    event NewRewardDistributor(address distributor, uint256 timestamp);\n\n    /// @dev owner\n    address public owner;\n\n    /// @dev implementation\n    address public distributorImplementation;\n\n    /// @dev list of all distributors\n    address[] public rewardDistributors;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    constructor(address _owner, address _distributorImplementation) {\n        owner = _owner;\n        distributorImplementation = _distributorImplementation;\n    }\n\n    function setDistributorImplementation(address _impl) external onlyOwner {\n        require(_impl != address(0), \"INVALID_IMPL\");\n        distributorImplementation = _impl;\n        emit NewImpl(_impl, block.timestamp);\n    }\n\n    function createRewardDistributor(\n        string calldata _name,\n        IERC20 _rewardToken,\n        uint256 _amountDistributePerSecond,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        address _guardian\n    ) external {\n        bytes32 salt =\n            keccak256(\n                abi.encode(\n                    _rewardToken,\n                    _amountDistributePerSecond,\n                    _startTimestamp,\n                    _guardian,\n                    rewardDistributors.length\n                )\n            );\n\n        IRewardDistributor newDistributor =\n            IRewardDistributor(distributorImplementation.cloneDeterministic(salt));\n\n        // initialize\n        newDistributor.initialize(\n            _name,\n            _rewardToken,\n            _amountDistributePerSecond,\n            _startTimestamp,\n            _endTimestamp,\n            _guardian\n        );\n\n        rewardDistributors.push(address(newDistributor));\n\n        emit NewRewardDistributor(address(newDistributor), block.timestamp);\n    }\n}\n"
    },
    "contracts/test/MockUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 /*amountOutMin*/,\n        address[] calldata path,\n        address to,\n        uint256 /*deadline*/\n    ) external virtual returns (uint256[] memory amounts) {\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n        IERC20(path[2]).transfer(to, amountIn);\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        amounts[1] = amountIn;\n        amounts[2] = amountIn;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20(\"Mock\", \"MCT\") {\n    uint8 _decimals;\n\n    constructor(uint8 __decimals) {\n        _decimals = __decimals;\n    }\n\n    function setBalanceTo(address to, uint256 value) public {\n        _mint(to, value);\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external {\n        _burn(_from, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/test/MockVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"../Vault.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockVault is Vault {\n    constructor() Vault() {}\n\n    function addProfit(MockToken _token, uint256 _amount) external {\n        // increase the underlying amount\n        _token.mint(address(this), _amount);\n    }\n}\n"
    },
    "contracts/oracle/PriceOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {UUPSProxiable} from \"../upgradability/UUPSProxiable.sol\";\nimport \"../interfaces/IPriceOracleAggregator.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title PriceOracleAggregator\n/// @author @samparsky\n/// @notice aggregator of price oracle for assets in LendingPairs\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract PriceOracleAggregator is IPriceOracleAggregator {\n    /// STATE VARIABLES ////\n\n    /// @dev admin allowed to update price oracle\n    address public owner;\n\n    /// @dev new owner\n    address internal newOwner;\n\n    /// @notice token to the oracle address\n    mapping(IERC20 => IOracle) public assetToOracle;\n\n    /// @notice stable to is stable status\n    mapping(IERC20 => bool) public stableTokens;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"INVALID_OWNER\");\n        owner = _owner;\n    }\n\n    /// @notice adds oracle for an asset e.g. ETH\n    /// @param _asset the oracle for the asset\n    /// @param _oracle the oracle address\n    function setOracleForAsset(IERC20[] calldata _asset, IOracle[] calldata _oracle)\n        external\n        override\n        onlyOwner\n    {\n        require(_asset.length == _oracle.length, \"INV\");\n        uint256 size = _asset.length;\n\n        for (uint256 i = 0; i < size; i++) {\n            IOracle oracle = _oracle[i];\n            require(address(oracle) != address(0), \"INVALID_ORACLE\");\n            assetToOracle[_asset[i]] = oracle;\n            emit UpdateOracle(_asset[i], oracle);\n        }\n    }\n\n    /// @notice remove oracle\n    function removeOracleForAsset(IERC20 _asset) external onlyOwner {\n        assetToOracle[_asset] = IOracle(address(0));\n        emit UpdateOracle(_asset, IOracle(address(0)));\n    }\n\n    /// @notice addStable use to add stablecoin asset that should be hardcoded\n    function addStable(IERC20[] calldata _tokens) public onlyOwner {\n        uint256 size = _tokens.length;\n        for (uint256 i = 0; i < size; i++) {\n            stableTokens[_tokens[i]] = true;\n            emit StableTokenAdded(_tokens[i], block.timestamp);\n        }\n    }\n\n    /// @notice returns price of token in USD in 1e8 decimals\n    /// @param _token token to fetch price\n    function getPriceInUSD(IERC20 _token) public view override returns (uint256 price) {\n        IOracle oracle = assetToOracle[_token];\n\n        if (address(oracle) != address(0)) {\n            price = uint256(assetToOracle[_token].latestAnswer());\n        } else if (stableTokens[_token] == true) {\n            price = 1e8;\n        }\n\n        require(price > 0, \"INVALID_PRICE\");\n    }\n\n    function getPriceInUSDMultiple(IERC20[] calldata _tokens)\n        external\n        view\n        override\n        returns (uint256[] memory prices)\n    {\n        uint256 size = _tokens.length;\n        for (uint256 i = 0; i < size; i++) {\n            prices[i] = getPriceInUSD(_tokens[i]);\n        }\n    }\n\n    /// @notice accept transfer of control\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"invalid owner\");\n        owner = newOwner;\n        newOwner = address(0);\n        emit OwnershipAccepted(newOwner, block.timestamp);\n    }\n\n    /// @notice Transfer control from current owner address to another\n    /// @param _newOwner The new team\n    function transferToNewOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"INVALID_NEW_OWNER\");\n        newOwner = _newOwner;\n        emit TransferControl(_newOwner, block.timestamp);\n    }\n}"
    },
    "contracts/test/MockPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockPriceOracle is IOracle {\n    int256 lastestAnswer;\n\n    constructor(int256 _price) {\n        lastestAnswer = _price;\n    }\n\n    function setPrice(int256 _newPrice) external {\n        lastestAnswer = _newPrice;\n    }\n\n    function latestAnswer() external view override returns (int256) {\n        return lastestAnswer;\n    }\n\n    function viewPriceInUSD() external view returns (int256) {\n        return lastestAnswer;\n    }\n}"
    },
    "contracts/test/MockChainlinkUSDAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract MockChainlinkUSDAdapter is IOracle {\n    function latestAnswer() external pure override returns (int256 price) {\n        return 1e8;\n    }\n\n    function viewPriceInUSD() external pure returns (uint256 price) {\n        return 1e8;\n    }\n}"
    },
    "contracts/oracle/adapter/ChainlinkUSDAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"../../interfaces/IOracle.sol\";\nimport \"../../interfaces/IChainlinkV3Aggregator.sol\";\n\ncontract ChainlinkUSDAdapter is IOracle {\n    /// @dev asset name\n    string public assetName;\n\n    /// @dev asset symbol\n    string public assetSymbol;\n\n    /// @notice the asset with the price oracle\n    address public immutable asset;\n\n    /// @notice chainlink aggregator with price in USD\n    IChainlinkV3Aggregator public immutable aggregator;\n\n    constructor(\n        string memory _assetName,\n        string memory _assetSymbol,\n        address _asset,\n        IChainlinkV3Aggregator _aggregator\n    ) {\n        require(_asset != address(0), \"invalid asset\");\n        require(address(_aggregator) != address(0), \"invalid aggregator\");\n        assetName = _assetName;\n        assetSymbol = _assetSymbol;\n        asset = _asset;\n        aggregator = _aggregator;\n    }\n\n    /// @dev returns price of asset in 1e8\n    function latestAnswer() external view override returns (int256) {\n        (, int256 price, , , ) = aggregator.latestRoundData();\n        return price;\n    }\n}\n"
    },
    "contracts/interfaces/IChainlinkV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\ninterface IChainlinkV3Aggregator {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/helper/LendingPairHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\nimport \"../interfaces/IBSLendingPair.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// @title LendingPair\n/// @author @samparsky\n/// @notice Helper functions to fetch data from LendingPairs\n///\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract LendingPairHelper {\n    IBSVault public immutable vault;\n\n    constructor(IBSVault _vault) {\n        vault = _vault;\n    }\n\n    function viewBorrowedValue(IBSLendingPair[] calldata pairs, address _account)\n        external\n        view\n        returns (uint256[] memory totals)\n    {\n        totals = new uint256[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IBSLendingPair pair = pairs[i];\n            totals[i] = pair.debtToken().balanceOf(_account);\n        }\n    }\n\n    function viewBorrowedValueInUSD(IBSLendingPair[] calldata pairs, address _account)\n        external\n        view\n        returns (uint256[] memory totals)\n    {\n        totals = new uint256[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IBSLendingPair pair = pairs[i];\n            uint256 currentBorrowBalance = pair.borrowBalancePrior(_account);\n            uint256 priceInUSD = pair.oracle().getPriceInUSD(pair.asset()) * currentBorrowBalance;\n            totals[i] = priceInUSD;\n        }\n    }\n\n    function viewBorrowLimit(IBSLendingPair[] calldata pairs, address _account)\n        external\n        view\n        returns (uint256[] memory totals)\n    {\n        totals = new uint256[](pairs.length);\n        for (uint256 i = 0; i < pairs.length; i++) {\n            IBSLendingPair pair = pairs[i];\n            uint256 underlyingAmount =\n                vault.toUnderlying(pair.collateralAsset(), pair.collateralOfAccount(_account));\n\n            totals[i] = pair.calcBorrowLimit(underlyingAmount);\n        }\n    }\n}\n"
    },
    "contracts/CollateralWrapperToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.1;\n\nimport \"./WrapperToken.sol\";\nimport \"./interfaces/IBSLendingPair.sol\";\n\n////////////////////////////////////////////////////////////////////////////////////////////\n/// @title CollateralWrapperToken\n/// @author @samparsky\n////////////////////////////////////////////////////////////////////////////////////////////\n\ncontract CollateralWrapperToken is WrapperToken {\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        uint256 maxWithdrawAllowed = IBSLendingPair(this.owner()).getMaxWithdrawAllowed(sender);\n        require(amount <= maxWithdrawAllowed, \"EXCEEDS_ALLOWED\");\n\n        super._transfer(sender, recipient, amount);\n    }\n\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}